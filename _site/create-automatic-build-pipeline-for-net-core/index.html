<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="theme" content="Chirpy v2.7.2"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="Create Automatic Builds for .Net and .Net Core Applications with Azure DevOps" /><meta name="author" content="Wolfgang Ofner" /><meta property="og:locale" content="en_US" /><meta name="description" content="Automated build processes should be a no-brainer nowadays but unfortunately, I still come across quite many projects which do their builds manually. In today’s post, I want to give an introduction to setting up an automated build pipeline for a .net and .NET Core application with Microsoft’s Azure DevOps Server. The DevOps Server is the on-premise version of Azure DevOps Services, but they are so similar that its negligible which one you use for this demo. I will use Azure DevOps Services. You can create a free account here. Creating your first Build Pipeline for a .net Framework Application In your Azure DevOps project go to Pipelines and then again Pipelines. There click on Create Pipeline and the wizard starts. Start the create pipeline wizard Here you can use either the new YAML editor which is selected by default or the classic editor. I use the classic editor by clicking on Use the classic editor at the bottom. In the next window, select the source of your code. The editor offers a wide range of repositories like Azure Repos Git, GitHub or even Subversion. Since I manage my code in Azure DevOps Services, I select Azure Repos Git and the wizard automatically selects your current project, repository and default branch. Click Continue to get to the template selection. Select the repository for your pipeline Azure DevOps Services offers a wide range of different templates as a starting point for your pipeline. There are templates for ASP .NET, Docker, Azure Functions and many more. You don’t have to select a template and could start without one by selecting Empty job or by importing a YAML file by selecting YAML. Since I have an ASP .NET MVC application, I select ASP. NET. Select a template for your pipeline Click on Apply and the pipeline will be created for you. The created build pipeline Inspecting the Settings of the Build Pipeline On top of your build pipeline, you can see six tabs with settings. Let’s check them out and see what we can configure there. Tasks The Tasks tab is the heart of your build pipeline and the part where all the magic happens. I will go over the steps in more detail in the next section. Variables In the Variables tab, you can create variables that can be used in every step of the pipeline. For builds, I barely use variables but you could set the username and password of an external service that you want to call. Azure DevOps already comes with a couple of predefined variables like the build configuration or platform. Variables for the build pipeline With the checkbox on the right (Settable at queue time), you can configure that these variables can be changed when you create a build. On the left are also Variable groups. There you can also set variables. The difference is that you can reuse a variable group for several pipelines whereas the Pipeline variables are specific for your pipeline. Triggers The Triggers tab configures continuous integration. On the following screenshot, you can see that I enabled continuous integration and trigger a build every time a change to a branch with the pattern release/* was made. (When I want to deploy I create a branch from master with the name release/sprint-XX. This puts the sprint-XX branch in the release folder and also triggers the build) Enable continuous integration It is also possible to schedule builds. For example, if you have integration tests that take a long time to finish, you don’t want to run them at every commit. You can run them every night, for example, Monday to Friday at 2 am or on the weekend. Schedule builds Options Here, you can edit the timeout for your builds and the build number format. I edited the number format to display the branch and then the date and build number. By default, only the date and build number are displayed. To do that, I am using the built-in variable Build.SourceBranchName.   Include the branch name in the build format number Retention Under this tab, you can configure your retention policies for your builds. The default is to keep 10 good builds for 30 days. I leave this as it is. Configure the retention policy of your build pipeline History The history tab shows not the history of your builds but the history of your build pipeline changes. I highly recommend you to always make a comment when you save changes in your pipeline. The history of the changes to the pipeline Inspecting the Build Tasks created by the ASP. NET Template Now that all the settings are as wished, let’s look at the steps of the deployment. Pipeline Here you can configure the agent pool, agent and artifact name for your build. The agent pool groups agents together. An agent builds (and later deploys) your application. Since I am using Azure DevOps Services, I leave the agent pool at Azure Pipelines because I want to use the agents which are hosted by Microsoft. For the agent, I also leave it as it is. If you are running a .Net core build, you could switch to Ubuntu. Get sources Under Get sources, you can change the project, repository and default branch for your build. You can also configure that a clean should be performed before the build. I set Clean to true and the Clean options to All build directories. Additionally, you could set a tag automatically for each build or each successful build. Configure the clean options Use NuGet The first set of your build pipeline is used to set up the NuGet.exe which will be used in the next step to restore your NuGet packages. I leave all the settings at their default values. NuGet restore This step restores all the Nuget packages of your solution. By default the NuGet packages in all projects. You can change this by changing the Path to solution from *\.sln to whatever fits you. Build solution The build solution step builds your application and also publishes it. The publish is necessary to deploy it later. You can also configure which version of Visual Studio should be used. You can choose from 2012 on all versions. Latest always selects the newest version. Test Assemblies Here, all test assemblies with test in their names are executed. You can select to run only impacted tests to speed up your build process. This setting executes only tests that were affected by the last commit. You can also configure to run all tests in isolation or even rerun failed tests. Publish symbols path This task publishes all *.pdb files which can be used for remote debugging. Publish Artifact Publish Artifact is necessary for an automated deployment. This step publishes all the files which you want to deploy later. If you don’t do this, the release pipeline won’t find any files to deploy. Running your first build Now that everything is set up, you can run your first build by clicking Save &amp; queue and then Save and run. Run your build This starts the build process. You can see the status by clicking on Agent job 1. On the following screenshot, you can see that the build step is already done and the tests are run right now. The status of the running build pipeline After a couple of minutes, your build should finish successfully. Creating a Build Pipeline for a .net Core Application Creating a build pipeline for .NET Core is the same process as for a .net framework application. The only difference is that I select ASP.NET Core as the template this time. Select .NET Core as your build template You can see a difference in the created build pipeline though. The .NET Core build pipeline Why I like the .net Core Build Pipeline better There are several reasons why I like the .NET Core build pipeline better than the one for a .net framework application. The first thing which got my attention is that all tasks look the same. All tasks except the last one use the dotnet CLI. The only difference is the argument (restore, build, publish and test). This means that I know exactly what’sgoing on and due to the similarity of the tasks, they are easy to configure. An even better new feature is that it is possible to zip a project during the publishing process. Before that, you had to use a Powershell script or the Archive files of Azure DevOps to create the zip. But this meant that you have an additional step and also duplicate data since you have the “normal” published files and afterwards the zipped ones. Zipping the files is necessary to save storage space but more importantly to speed up the deployment process. Conclusion This post showed how you can quickly set up an automated build pipeline for your .net or .NET Core application in Azure DevOps. This is the first step to increasing the development velocity and reducing the bugs and later on also the deployment time." /><meta property="og:description" content="Automated build processes should be a no-brainer nowadays but unfortunately, I still come across quite many projects which do their builds manually. In today’s post, I want to give an introduction to setting up an automated build pipeline for a .net and .NET Core application with Microsoft’s Azure DevOps Server. The DevOps Server is the on-premise version of Azure DevOps Services, but they are so similar that its negligible which one you use for this demo. I will use Azure DevOps Services. You can create a free account here. Creating your first Build Pipeline for a .net Framework Application In your Azure DevOps project go to Pipelines and then again Pipelines. There click on Create Pipeline and the wizard starts. Start the create pipeline wizard Here you can use either the new YAML editor which is selected by default or the classic editor. I use the classic editor by clicking on Use the classic editor at the bottom. In the next window, select the source of your code. The editor offers a wide range of repositories like Azure Repos Git, GitHub or even Subversion. Since I manage my code in Azure DevOps Services, I select Azure Repos Git and the wizard automatically selects your current project, repository and default branch. Click Continue to get to the template selection. Select the repository for your pipeline Azure DevOps Services offers a wide range of different templates as a starting point for your pipeline. There are templates for ASP .NET, Docker, Azure Functions and many more. You don’t have to select a template and could start without one by selecting Empty job or by importing a YAML file by selecting YAML. Since I have an ASP .NET MVC application, I select ASP. NET. Select a template for your pipeline Click on Apply and the pipeline will be created for you. The created build pipeline Inspecting the Settings of the Build Pipeline On top of your build pipeline, you can see six tabs with settings. Let’s check them out and see what we can configure there. Tasks The Tasks tab is the heart of your build pipeline and the part where all the magic happens. I will go over the steps in more detail in the next section. Variables In the Variables tab, you can create variables that can be used in every step of the pipeline. For builds, I barely use variables but you could set the username and password of an external service that you want to call. Azure DevOps already comes with a couple of predefined variables like the build configuration or platform. Variables for the build pipeline With the checkbox on the right (Settable at queue time), you can configure that these variables can be changed when you create a build. On the left are also Variable groups. There you can also set variables. The difference is that you can reuse a variable group for several pipelines whereas the Pipeline variables are specific for your pipeline. Triggers The Triggers tab configures continuous integration. On the following screenshot, you can see that I enabled continuous integration and trigger a build every time a change to a branch with the pattern release/* was made. (When I want to deploy I create a branch from master with the name release/sprint-XX. This puts the sprint-XX branch in the release folder and also triggers the build) Enable continuous integration It is also possible to schedule builds. For example, if you have integration tests that take a long time to finish, you don’t want to run them at every commit. You can run them every night, for example, Monday to Friday at 2 am or on the weekend. Schedule builds Options Here, you can edit the timeout for your builds and the build number format. I edited the number format to display the branch and then the date and build number. By default, only the date and build number are displayed. To do that, I am using the built-in variable Build.SourceBranchName.   Include the branch name in the build format number Retention Under this tab, you can configure your retention policies for your builds. The default is to keep 10 good builds for 30 days. I leave this as it is. Configure the retention policy of your build pipeline History The history tab shows not the history of your builds but the history of your build pipeline changes. I highly recommend you to always make a comment when you save changes in your pipeline. The history of the changes to the pipeline Inspecting the Build Tasks created by the ASP. NET Template Now that all the settings are as wished, let’s look at the steps of the deployment. Pipeline Here you can configure the agent pool, agent and artifact name for your build. The agent pool groups agents together. An agent builds (and later deploys) your application. Since I am using Azure DevOps Services, I leave the agent pool at Azure Pipelines because I want to use the agents which are hosted by Microsoft. For the agent, I also leave it as it is. If you are running a .Net core build, you could switch to Ubuntu. Get sources Under Get sources, you can change the project, repository and default branch for your build. You can also configure that a clean should be performed before the build. I set Clean to true and the Clean options to All build directories. Additionally, you could set a tag automatically for each build or each successful build. Configure the clean options Use NuGet The first set of your build pipeline is used to set up the NuGet.exe which will be used in the next step to restore your NuGet packages. I leave all the settings at their default values. NuGet restore This step restores all the Nuget packages of your solution. By default the NuGet packages in all projects. You can change this by changing the Path to solution from *\.sln to whatever fits you. Build solution The build solution step builds your application and also publishes it. The publish is necessary to deploy it later. You can also configure which version of Visual Studio should be used. You can choose from 2012 on all versions. Latest always selects the newest version. Test Assemblies Here, all test assemblies with test in their names are executed. You can select to run only impacted tests to speed up your build process. This setting executes only tests that were affected by the last commit. You can also configure to run all tests in isolation or even rerun failed tests. Publish symbols path This task publishes all *.pdb files which can be used for remote debugging. Publish Artifact Publish Artifact is necessary for an automated deployment. This step publishes all the files which you want to deploy later. If you don’t do this, the release pipeline won’t find any files to deploy. Running your first build Now that everything is set up, you can run your first build by clicking Save &amp; queue and then Save and run. Run your build This starts the build process. You can see the status by clicking on Agent job 1. On the following screenshot, you can see that the build step is already done and the tests are run right now. The status of the running build pipeline After a couple of minutes, your build should finish successfully. Creating a Build Pipeline for a .net Core Application Creating a build pipeline for .NET Core is the same process as for a .net framework application. The only difference is that I select ASP.NET Core as the template this time. Select .NET Core as your build template You can see a difference in the created build pipeline though. The .NET Core build pipeline Why I like the .net Core Build Pipeline better There are several reasons why I like the .NET Core build pipeline better than the one for a .net framework application. The first thing which got my attention is that all tasks look the same. All tasks except the last one use the dotnet CLI. The only difference is the argument (restore, build, publish and test). This means that I know exactly what’sgoing on and due to the similarity of the tasks, they are easy to configure. An even better new feature is that it is possible to zip a project during the publishing process. Before that, you had to use a Powershell script or the Archive files of Azure DevOps to create the zip. But this meant that you have an additional step and also duplicate data since you have the “normal” published files and afterwards the zipped ones. Zipping the files is necessary to save storage space but more importantly to speed up the deployment process. Conclusion This post showed how you can quickly set up an automated build pipeline for your .net or .NET Core application in Azure DevOps. This is the first step to increasing the development velocity and reducing the bugs and later on also the deployment time." /><link rel="canonical" href="https://www.programmingwithwolfgang.com/create-automatic-build-pipeline-for-net-core/" /><meta property="og:url" content="https://www.programmingwithwolfgang.com/create-automatic-build-pipeline-for-net-core/" /><meta property="og:site_name" content="Programming With Wolfgang" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-11-18T16:15:30+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Create Automatic Builds for .Net and .Net Core Applications with Azure DevOps" /><meta name="twitter:site" content="@wolfgang_ofner" /><meta name="twitter:creator" content="@Wolfgang Ofner" /><meta name="google-site-verification" content="xxsPm-h6A0B6a0QMgqXO80PU4DbMt4Dq06p-SGzB3TU" /> <script type="application/ld+json"> {"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.programmingwithwolfgang.com/create-automatic-build-pipeline-for-net-core/"},"author":{"@type":"Person","name":"Wolfgang Ofner"},"url":"https://www.programmingwithwolfgang.com/create-automatic-build-pipeline-for-net-core/","description":"Automated build processes should be a no-brainer nowadays but unfortunately, I still come across quite many projects which do their builds manually. In today’s post, I want to give an introduction to setting up an automated build pipeline for a .net and .NET Core application with Microsoft’s Azure DevOps Server. The DevOps Server is the on-premise version of Azure DevOps Services, but they are so similar that its negligible which one you use for this demo. I will use Azure DevOps Services. You can create a free account here. Creating your first Build Pipeline for a .net Framework Application In your Azure DevOps project go to Pipelines and then again Pipelines. There click on Create Pipeline and the wizard starts. Start the create pipeline wizard Here you can use either the new YAML editor which is selected by default or the classic editor. I use the classic editor by clicking on Use the classic editor at the bottom. In the next window, select the source of your code. The editor offers a wide range of repositories like Azure Repos Git, GitHub or even Subversion. Since I manage my code in Azure DevOps Services, I select Azure Repos Git and the wizard automatically selects your current project, repository and default branch. Click Continue to get to the template selection. Select the repository for your pipeline Azure DevOps Services offers a wide range of different templates as a starting point for your pipeline. There are templates for ASP .NET, Docker, Azure Functions and many more. You don’t have to select a template and could start without one by selecting Empty job or by importing a YAML file by selecting YAML. Since I have an ASP .NET MVC application, I select ASP. NET. Select a template for your pipeline Click on Apply and the pipeline will be created for you. The created build pipeline Inspecting the Settings of the Build Pipeline On top of your build pipeline, you can see six tabs with settings. Let’s check them out and see what we can configure there. Tasks The Tasks tab is the heart of your build pipeline and the part where all the magic happens. I will go over the steps in more detail in the next section. Variables In the Variables tab, you can create variables that can be used in every step of the pipeline. For builds, I barely use variables but you could set the username and password of an external service that you want to call. Azure DevOps already comes with a couple of predefined variables like the build configuration or platform. Variables for the build pipeline With the checkbox on the right (Settable at queue time), you can configure that these variables can be changed when you create a build. On the left are also Variable groups. There you can also set variables. The difference is that you can reuse a variable group for several pipelines whereas the Pipeline variables are specific for your pipeline. Triggers The Triggers tab configures continuous integration. On the following screenshot, you can see that I enabled continuous integration and trigger a build every time a change to a branch with the pattern release/* was made. (When I want to deploy I create a branch from master with the name release/sprint-XX. This puts the sprint-XX branch in the release folder and also triggers the build) Enable continuous integration It is also possible to schedule builds. For example, if you have integration tests that take a long time to finish, you don’t want to run them at every commit. You can run them every night, for example, Monday to Friday at 2 am or on the weekend. Schedule builds Options Here, you can edit the timeout for your builds and the build number format. I edited the number format to display the branch and then the date and build number. By default, only the date and build number are displayed. To do that, I am using the built-in variable Build.SourceBranchName.   Include the branch name in the build format number Retention Under this tab, you can configure your retention policies for your builds. The default is to keep 10 good builds for 30 days. I leave this as it is. Configure the retention policy of your build pipeline History The history tab shows not the history of your builds but the history of your build pipeline changes. I highly recommend you to always make a comment when you save changes in your pipeline. The history of the changes to the pipeline Inspecting the Build Tasks created by the ASP. NET Template Now that all the settings are as wished, let’s look at the steps of the deployment. Pipeline Here you can configure the agent pool, agent and artifact name for your build. The agent pool groups agents together. An agent builds (and later deploys) your application. Since I am using Azure DevOps Services, I leave the agent pool at Azure Pipelines because I want to use the agents which are hosted by Microsoft. For the agent, I also leave it as it is. If you are running a .Net core build, you could switch to Ubuntu. Get sources Under Get sources, you can change the project, repository and default branch for your build. You can also configure that a clean should be performed before the build. I set Clean to true and the Clean options to All build directories. Additionally, you could set a tag automatically for each build or each successful build. Configure the clean options Use NuGet The first set of your build pipeline is used to set up the NuGet.exe which will be used in the next step to restore your NuGet packages. I leave all the settings at their default values. NuGet restore This step restores all the Nuget packages of your solution. By default the NuGet packages in all projects. You can change this by changing the Path to solution from *\\.sln to whatever fits you. Build solution The build solution step builds your application and also publishes it. The publish is necessary to deploy it later. You can also configure which version of Visual Studio should be used. You can choose from 2012 on all versions. Latest always selects the newest version. Test Assemblies Here, all test assemblies with test in their names are executed. You can select to run only impacted tests to speed up your build process. This setting executes only tests that were affected by the last commit. You can also configure to run all tests in isolation or even rerun failed tests. Publish symbols path This task publishes all *.pdb files which can be used for remote debugging. Publish Artifact Publish Artifact is necessary for an automated deployment. This step publishes all the files which you want to deploy later. If you don’t do this, the release pipeline won’t find any files to deploy. Running your first build Now that everything is set up, you can run your first build by clicking Save &amp; queue and then Save and run. Run your build This starts the build process. You can see the status by clicking on Agent job 1. On the following screenshot, you can see that the build step is already done and the tests are run right now. The status of the running build pipeline After a couple of minutes, your build should finish successfully. Creating a Build Pipeline for a .net Core Application Creating a build pipeline for .NET Core is the same process as for a .net framework application. The only difference is that I select ASP.NET Core as the template this time. Select .NET Core as your build template You can see a difference in the created build pipeline though. The .NET Core build pipeline Why I like the .net Core Build Pipeline better There are several reasons why I like the .NET Core build pipeline better than the one for a .net framework application. The first thing which got my attention is that all tasks look the same. All tasks except the last one use the dotnet CLI. The only difference is the argument (restore, build, publish and test). This means that I know exactly what’sgoing on and due to the similarity of the tasks, they are easy to configure. An even better new feature is that it is possible to zip a project during the publishing process. Before that, you had to use a Powershell script or the Archive files of Azure DevOps to create the zip. But this meant that you have an additional step and also duplicate data since you have the “normal” published files and afterwards the zipped ones. Zipping the files is necessary to save storage space but more importantly to speed up the deployment process. Conclusion This post showed how you can quickly set up an automated build pipeline for your .net or .NET Core application in Azure DevOps. This is the first step to increasing the development velocity and reducing the bugs and later on also the deployment time.","@type":"BlogPosting","headline":"Create Automatic Builds for .Net and .Net Core Applications with Azure DevOps","dateModified":"2020-12-30T18:43:38+01:00","datePublished":"2019-11-18T16:15:30+01:00","@context":"https://schema.org"}</script><title>Create Automatic Builds for .Net and .Net Core Applications with Azure DevOps | Programming With Wolfgang</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="preload" href="/assets/css/post.css" as="style"><link rel="stylesheet" href="/assets/css/post.css"><link rel="preload" as="style" href="/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/css/lib/bootstrap-toc.min.css" /> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="/assets/js/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-112077092-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-112077092-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/author/wolfgang-small.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Programming With Wolfgang</a></div><div class="site-subtitle font-italic">Let's talk programming</div></div><div class="w-100 d-flex justify-content-center"> <i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span></div><ul class="w-100" style="margin-top: 1em;"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tabs/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tabs/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/tabs/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/tabs/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/wolfgangofner" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/wolfgang_ofner" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href="https://www.linkedin.com/in/wolfgangofner" aria-label="linkedin" class="order-5" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['wolfgang','programmingwithwolfgang.com'].join('@')" aria-label="email" class="order-6" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-7" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="d-sm-none row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Create Automatic Builds for .Net and .Net Core Applications with Azure DevOps</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Create Automatic Builds for .Net and .Net Core Applications with Azure DevOps</div><div style="visibility:hidden;"> <i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel">Cancel</span></div></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Create Automatic Builds for .Net and .Net Core Applications with Azure DevOps</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Mon, Nov 18, 2019, 4:15 PM +0100" > Nov 18, 2019 <i class="unloaded">2019-11-18T16:15:30+01:00</i> </span> by <span class="author"> Wolfgang Ofner </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Wed, Dec 30, 2020, 6:43 PM +0100" > Dec 30, 2020 <i class="unloaded">2020-12-30T18:43:38+01:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1507 words">23 min</span></div></div><div class="post-content"><p>Automated build processes should be a no-brainer nowadays but unfortunately, I still come across quite many projects which do their builds manually. In today’s post, I want to give an introduction to setting up an automated build pipeline for a .net and .NET Core application with Microsoft’s Azure DevOps Server. The DevOps Server is the on-premise version of Azure DevOps Services, but they are so similar that its negligible which one you use for this demo. I will use Azure DevOps Services. You can create a free account <a href="https://azure.microsoft.com/en-us/services/devops/" target="_blank" rel="noopener noreferrer">here</a>.</p><h2 id="creating-your-first-build-pipeline-for-a-net-framework-application">Creating your first Build Pipeline for a .net Framework Application</h2><p>In your Azure DevOps project go to Pipelines and then again Pipelines. There click on Create Pipeline and the wizard starts.</p><div class="col-12 col-sm-10 aligncenter"> <a href="/assets/img/posts/2019/11/Start-the-create-pipeline-wizzard.jpg"><img loading="lazy" src="/assets/img/posts/2019/11/Start-the-create-pipeline-wizzard.jpg" alt="Start the create pipeline wizard" /></a><p> Start the create pipeline wizard</p></div><p>Here you can use either the new YAML editor which is selected by default or the classic editor. I use the classic editor by clicking on Use the classic editor at the bottom. In the next window, select the source of your code. The editor offers a wide range of repositories like Azure Repos Git, GitHub or even Subversion. Since I manage my code in Azure DevOps Services, I select Azure Repos Git and the wizard automatically selects your current project, repository and default branch. Click Continue to get to the template selection.</p><div class="col-12 col-sm-10 aligncenter"> <a href="/assets/img/posts/2019/11/Select-the-repository-for-your-pipeline.jpg"><img loading="lazy" src="/assets/img/posts/2019/11/Select-the-repository-for-your-pipeline.jpg" alt="Select the repository for your pipeline" /></a><p> Select the repository for your pipeline</p></div><p>Azure DevOps Services offers a wide range of different templates as a starting point for your pipeline. There are templates for ASP .NET, Docker, Azure Functions and many more. You don’t have to select a template and could start without one by selecting Empty job or by importing a YAML file by selecting YAML. Since I have an ASP .NET MVC application, I select ASP. NET.</p><div class="col-12 col-sm-10 aligncenter"> <a href="/assets/img/posts/2019/11/Select-a-template-for-your-pipeline.jpg"><img loading="lazy" src="/assets/img/posts/2019/11/Select-a-template-for-your-pipeline.jpg" alt="Select a template for your pipeline" /></a><p> Select a template for your pipeline</p></div><p>Click on Apply and the pipeline will be created for you.</p><div class="col-12 col-sm-10 aligncenter"> <a href="/assets/img/posts/2019/11/The-created-build-pipeline.jpg"><img loading="lazy" src="/assets/img/posts/2019/11/The-created-build-pipeline.jpg" alt="The created build pipeline" /></a><p> The created build pipeline</p></div><h3 id="inspecting-the-settings-of-the-build-pipeline">Inspecting the Settings of the Build Pipeline</h3><p>On top of your build pipeline, you can see six tabs with settings. Let’s check them out and see what we can configure there.</p><h4 id="tasks">Tasks</h4><p>The Tasks tab is the heart of your build pipeline and the part where all the magic happens. I will go over the steps in more detail in the next section.</p><h4 id="variables">Variables</h4><p>In the Variables tab, you can create variables that can be used in every step of the pipeline. For builds, I barely use variables but you could set the username and password of an external service that you want to call. Azure DevOps already comes with a couple of predefined variables like the build configuration or platform.</p><div class="col-12 col-sm-10 aligncenter"> <a href="/assets/img/posts/2019/11/Variables-for-the-build-pipeline.jpg"><img loading="lazy" src="/assets/img/posts/2019/11/Variables-for-the-build-pipeline.jpg" alt="Variables for the build pipeline" /></a><p> Variables for the build pipeline</p></div><p>With the checkbox on the right (Settable at queue time), you can configure that these variables can be changed when you create a build. On the left are also Variable groups. There you can also set variables. The difference is that you can reuse a variable group for several pipelines whereas the Pipeline variables are specific for your pipeline.</p><h4 id="triggers">Triggers</h4><p>The Triggers tab configures continuous integration. On the following screenshot, you can see that I enabled continuous integration and trigger a build every time a change to a branch with the pattern release/* was made. (When I want to deploy I create a branch from master with the name release/sprint-XX. This puts the sprint-XX branch in the release folder and also triggers the build)</p><div class="col-12 col-sm-10 aligncenter"> <a href="/assets/img/posts/2019/11/Enable-continuous-integration.jpg"><img loading="lazy" src="/assets/img/posts/2019/11/Enable-continuous-integration.jpg" alt="Enable continuous integration" /></a><p> Enable continuous integration</p></div><p>It is also possible to schedule builds. For example, if you have integration tests that take a long time to finish, you don’t want to run them at every commit. You can run them every night, for example, Monday to Friday at 2 am or on the weekend.</p><div class="col-12 col-sm-10 aligncenter"> <a href="/assets/img/posts/2019/11/Schedule-builds.jpg"><img loading="lazy" src="/assets/img/posts/2019/11/Schedule-builds.jpg" alt="Schedule builds" /></a><p> Schedule builds</p></div><h4 id="options">Options</h4><p>Here, you can edit the timeout for your builds and the build number format. I edited the number format to display the branch and then the date and build number. By default, only the date and build number are displayed. To do that, I am using the built-in variable Build.SourceBranchName.</p><p> </p><div class="col-12 col-sm-10 aligncenter"> <a href="/assets/img/posts/2019/11/Include-the-branch-name-in-the-build-format-number.jpg"><img loading="lazy" src="/assets/img/posts/2019/11/Include-the-branch-name-in-the-build-format-number.jpg" alt="Include the branch name in the build format number" /></a><p> Include the branch name in the build format number</p></div><h4 id="retention">Retention</h4><p>Under this tab, you can configure your retention policies for your builds. The default is to keep 10 good builds for 30 days. I leave this as it is.</p><div class="col-12 col-sm-10 aligncenter"> <a href="/assets/img/posts/2019/11/Configure-the-retention-policy-of-your-build-pipeline.jpg"><img loading="lazy" src="/assets/img/posts/2019/11/Configure-the-retention-policy-of-your-build-pipeline.jpg" alt="Configure the retention policy of your build pipeline" /></a><p> Configure the retention policy of your build pipeline</p></div><h4 id="history">History</h4><p>The history tab shows not the history of your builds but the history of your build pipeline changes. I highly recommend you to always make a comment when you save changes in your pipeline.</p><div class="col-12 col-sm-10 aligncenter"> <a href="/assets/img/posts/2019/11/The-history-of-the-changes-to-the-pipeline.jpg"><img loading="lazy" src="/assets/img/posts/2019/11/The-history-of-the-changes-to-the-pipeline.jpg" alt="The history of the changes to the pipeline" /></a><p> The history of the changes to the pipeline</p></div><h3 id="inspecting-the-build-tasks-created-by-the-asp-net-template">Inspecting the Build Tasks created by the ASP. NET Template</h3><p>Now that all the settings are as wished, let’s look at the steps of the deployment.</p><h4 id="pipeline">Pipeline</h4><p>Here you can configure the agent pool, agent and artifact name for your build. The agent pool groups agents together. An agent builds (and later deploys) your application. Since I am using Azure DevOps Services, I leave the agent pool at Azure Pipelines because I want to use the agents which are hosted by Microsoft. For the agent, I also leave it as it is. If you are running a .Net core build, you could switch to Ubuntu.</p><h4 id="get-sources">Get sources</h4><p>Under Get sources, you can change the project, repository and default branch for your build. You can also configure that a clean should be performed before the build. I set Clean to true and the Clean options to All build directories. Additionally, you could set a tag automatically for each build or each successful build.</p><div class="col-12 col-sm-10 aligncenter"> <a href="/assets/img/posts/2019/11/Configure-the-clean-options.jpg"><img loading="lazy" src="/assets/img/posts/2019/11/Configure-the-clean-options.jpg" alt="Configure the clean options" /></a><p> Configure the clean options</p></div><h4 id="use-nuget">Use NuGet</h4><p>The first set of your build pipeline is used to set up the NuGet.exe which will be used in the next step to restore your NuGet packages. I leave all the settings at their default values.</p><h4 id="nuget-restore">NuGet restore</h4><p>This step restores all the Nuget packages of your solution. By default the NuGet packages in all projects. You can change this by changing the Path to solution from <em>*\</em>.sln to whatever fits you.</p><h4 id="build-solution">Build solution</h4><p>The build solution step builds your application and also publishes it. The publish is necessary to deploy it later. You can also configure which version of Visual Studio should be used. You can choose from 2012 on all versions. Latest always selects the newest version.</p><h4 id="test-assemblies">Test Assemblies</h4><p>Here, all test assemblies with test in their names are executed. You can select to run only impacted tests to speed up your build process. This setting executes only tests that were affected by the last commit. You can also configure to run all tests in isolation or even rerun failed tests.</p><h4 id="publish-symbols-path">Publish symbols path</h4><p>This task publishes all *.pdb files which can be used for remote debugging.</p><h4 id="publish-artifact">Publish Artifact</h4><p>Publish Artifact is necessary for an automated deployment. This step publishes all the files which you want to deploy later. If you don’t do this, the release pipeline won’t find any files to deploy.</p><h2 id="running-your-first-build">Running your first build</h2><p>Now that everything is set up, you can run your first build by clicking Save &amp; queue and then Save and run.</p><div class="col-12 col-sm-10 aligncenter"> <a href="/assets/img/posts/2019/11/Run-your-build.jpg"><img loading="lazy" src="/assets/img/posts/2019/11/Run-your-build.jpg" alt="Run your build" /></a><p> Run your build</p></div><p>This starts the build process. You can see the status by clicking on Agent job 1. On the following screenshot, you can see that the build step is already done and the tests are run right now.</p><div class="col-12 col-sm-10 aligncenter"> <a href="/assets/img/posts/2019/11/The-status-of-the-running-build-pipeline.jpg"><img loading="lazy" src="/assets/img/posts/2019/11/The-status-of-the-running-build-pipeline.jpg" alt="The status of the running build " /></a><p> The status of the running build pipeline</p></div><p>After a couple of minutes, your build should finish successfully.</p><h2 id="creating-a-build-pipeline-for-a-net-core-application">Creating a Build Pipeline for a .net Core Application</h2><p>Creating a build pipeline for .NET Core is the same process as for a .net framework application. The only difference is that I select ASP.NET Core as the template this time.</p><div class="col-12 col-sm-10 aligncenter"> <a href="/assets/img/posts/2019/11/Select-.net-core-as-your-build-template.jpg"><img loading="lazy" src="/assets/img/posts/2019/11/Select-.net-core-as-your-build-template.jpg" alt="Select .NET Core as your build template" /></a><p> Select .NET Core as your build template</p></div><p>You can see a difference in the created build pipeline though.</p><div class="col-12 col-sm-10 aligncenter"> <a href="/assets/img/posts/2019/11/The-.net-core-build-pipeline.jpg"><img loading="lazy" src="/assets/img/posts/2019/11/The-.net-core-build-pipeline.jpg" alt="The .NET Core pipeline" /></a><p> The .NET Core build pipeline</p></div><h2 id="why-i-like-the-net-core-build-pipeline-better">Why I like the .net Core Build Pipeline better</h2><p>There are several reasons why I like the .NET Core build pipeline better than the one for a .net framework application.</p><p>The first thing which got my attention is that all tasks look the same. All tasks except the last one use the dotnet CLI. The only difference is the argument (restore, build, publish and test). This means that I know exactly what’sgoing on and due to the similarity of the tasks, they are easy to configure.</p><p>An even better new feature is that it is possible to zip a project during the publishing process. Before that, you had to use a Powershell script or the Archive files of Azure DevOps to create the zip. But this meant that you have an additional step and also duplicate data since you have the “normal” published files and afterwards the zipped ones. Zipping the files is necessary to save storage space but more importantly to speed up the deployment process.</p><h2 id="conclusion">Conclusion</h2><p>This post showed how you can quickly set up an automated build pipeline for your .net or .NET Core application in Azure DevOps. This is the first step to increasing the development velocity and reducing the bugs and later on also the deployment time.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/devops/'>DevOps</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/net-core/" class="post-tag no-text-decoration" >NET Core</a> <a href="/tags/asp-net-core-mvc/" class="post-tag no-text-decoration" >ASP.NET Core MVC</a> <a href="/tags/asp-net-mvc/" class="post-tag no-text-decoration" >ASP.NET MVC</a> <a href="/tags/azure-devops/" class="post-tag no-text-decoration" >Azure DevOps</a> <a href="/tags/continous-integration/" class="post-tag no-text-decoration" >Continous Integration</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Create Automatic Builds for .Net and .Net Core Applications with Azure DevOps - Programming With Wolfgang&url=https://www.programmingwithwolfgang.com/create-automatic-build-pipeline-for-net-core/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Create Automatic Builds for .Net and .Net Core Applications with Azure DevOps - Programming With Wolfgang&u=https://www.programmingwithwolfgang.com/create-automatic-build-pipeline-for-net-core/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Create Automatic Builds for .Net and .Net Core Applications with Azure DevOps - Programming With Wolfgang&url=https://www.programmingwithwolfgang.com/create-automatic-build-pipeline-for-net-core/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://www.programmingwithwolfgang.com/create-automatic-build-pipeline-for-net-core/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/helm-getting-started/">Helm - Getting Started</a><li><a href="/override-appsettings-in-kubernetes/">Override Appsettings in Kubernetes</a><li><a href="/mediator-pattern-in-asp-net-core-3-1/">Mediator Pattern in ASP .NET Core 3.1</a><li><a href="/microservice-series-from-zero-to-hero/">Microservice Series - From Zero to Hero</a><li><a href="/blazor-server-vs-blazor-webassembly/">Blazor Server vs. Blazor WebAssembly</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/c/">C#</a> <a class="post-tag" href="/tags/azure/">Azure</a> <a class="post-tag" href="/tags/learning/">Learning</a> <a class="post-tag" href="/tags/70-532/">70-532</a> <a class="post-tag" href="/tags/certification/">Certification</a> <a class="post-tag" href="/tags/exam/">Exam</a> <a class="post-tag" href="/tags/docker/">Docker</a> <a class="post-tag" href="/tags/azure-devops/">Azure DevOps</a> <a class="post-tag" href="/tags/net-core/">NET Core</a> <a class="post-tag" href="/tags/microservice/">Microservice</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/build-net-core-in-ci-pipeline-in-azure-devops/"><div class="card-body"> <span class="timeago small" > Oct 13, 2020 <i class="unloaded">2020-10-13T17:20:53+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Build .NET Core in a CI Pipeline in Azure DevOps</h3><div class="text-muted small"><p> A crucial feature of DevOps is to give the developer fast feedback if their code changes work. This can be done by automatically building code and running tests every time changes are checked-in. T...</p></div></div></a></div><div class="card"> <a href="/getting-to-know-the-startup-class-of-asp-net-core-mvc/"><div class="card-body"> <span class="timeago small" > Apr 29, 2019 <i class="unloaded">2019-04-29T11:15:53+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Getting to know the Startup Class of ASP.Net Core MVC</h3><div class="text-muted small"><p> Every .NET Core web application has a Program class with a static Main method. The Startup class of .Net core is the new version of the Global.asax file. This class is responsible for starting the...</p></div></div></a></div><div class="card"> <a href="/middleware-in-asp-net-core-mvc/"><div class="card-body"> <span class="timeago small" > May 1, 2019 <i class="unloaded">2019-05-01T11:17:11+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Middleware in ASP.NET Core MVC</h3><div class="text-muted small"><p> Middleware is the term used for the components that are combined to form the request pipeline. This pipeline is arranged like a chain. The request is either returned by the middleware or passed to ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/asp-net-core-logging-to-a-database-with-nlog/" class="btn btn-outline-primary"><p>ASP.NET Core logging to a database with NLog</p></a> <a href="/create-policies-for-your-branches-in-azure-devops/" class="btn btn-outline-primary"><p>Create Policies for your Branches in Azure DevOps</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="font-italic text-center text-muted small"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> var options = { scriptUrl: '//programmingwithwolfgang.disqus.com/embed.js', disqusConfig: function() { this.page.url = 'https://www.programmingwithwolfgang.com/create-automatic-build-pipeline-for-net-core/'; this.page.identifier = '/create-automatic-build-pipeline-for-net-core/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://twitter.com/wolfgang_ofner">Wolfgang Ofner</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy/" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/c/">C#</a> <a class="post-tag" href="/tags/azure/">Azure</a> <a class="post-tag" href="/tags/learning/">Learning</a> <a class="post-tag" href="/tags/70-532/">70 532</a> <a class="post-tag" href="/tags/certification/">Certification</a> <a class="post-tag" href="/tags/exam/">Exam</a> <a class="post-tag" href="/tags/docker/">Docker</a> <a class="post-tag" href="/tags/azure-devops/">Azure DevOps</a> <a class="post-tag" href="/tags/net-core/">NET Core</a> <a class="post-tag" href="/tags/microservice/">Microservice</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.programmingwithwolfgang.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>

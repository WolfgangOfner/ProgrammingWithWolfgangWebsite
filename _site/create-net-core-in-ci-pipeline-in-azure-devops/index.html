<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="theme" content="Chirpy v2.7.2"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="Create a .NET Core CI Pipeline in Azure DevOps" /><meta name="author" content="Wolfgang Ofner" /><meta property="og:locale" content="en_US" /><meta name="description" content="A crucial feature of DevOps is to give the developer fast feedback if their code changes work. This can be done by automatically building code and running tests every time changes are checked-in. Today, I will show how to create a CI pipeline (continuous integration) for ASP .NET Core. Create a .NET Core CI Pipeline in Azure DevOps In my last post, Creating a Microservice with .NET Core 3.1, I created a new ASP .NET Core microservice. I will use the CI pipeline to build all projects and run all unit tests in the repository. You can find the code of the demo on Github. In your Azure DevOps project, go to Pipelines and click Create Pipeline. Create a new CI Pipeline In the next window, select where you have your code stored. I select GitHub for this Demo. Usually, I have my code directly in Azure DevOps, then I would select Azure Repos Git. On the bottom, you can see “Use the classic editor”. This opens the old task-based editor. You shouldn’t use this anymore since the new standard is to use YML pipelines. This enables you to have your pipeline in your source control. Select where your code is Authorize Github Since the code is on GitHub, I have to authorize Azure Pipelines to access my repositories. If the code was on an Azure Repos, this step wouldn’t be necessary. Authorize Azure Pipelines to access Github After authorizing Azure Pipelines for GitHub, all your repositories will be displayed. Search and select for the repository, you want to make the CI pipeline for. In my case, I select the .NetCoreMicroserviceCiCdAks repository. Select your repository On the next window, I have to approve to install Azure Pipelines in my Github repository. This allows Azure DevOps to access the repository and write to the code. This is necessary because the CI pipeline will be added to the source control. Again, this is not necessary when you have your code in Azure DevOps. Select a Template On the next step, select a template for your CI pipeline. Azure DevOps offers many templates like Docker, Kubernetes, PHP, or Node.js. Since my application is a .NET Core microservice, I select the ASP.NET Core template. Select the ASP.NET Core template for your CI Pipeline That’s it. The template created a simple CI pipeline and you can use it to build your .NET Core solution. In the next section, I will go into more detail about the functionality and add more steps. The template created a simple CI Pipeline Add more steps to the CI Pipeline Before we add more steps to the CI pipeline, let’s have a look at what the template created. Analyze the CI Pipeline from the Template Above the .yml editor, you can see the path to the pipeline yml file in your source control. In my case it is WolfgangOfner/.NetCoreMicroserviceCiCdAks/dotnetcoreCIPipeline.yml. I renamed the file because I want to add more later. Line 1 through 8 configures the pipeline. The trigger section defines that the pipeline is automatically triggered when something changes on the master branch. The pool section defines that the pipeline is executed on an ubuntu agent and the variables section lets you define variables for the pipeline. By default, only the buildConfiguration is set to Release. On line 10 starts the first build step that executes a dotnet build in sets the configuration to Release by using the previously defined buildConfiguration variable. Additionally, a display name is set to identify the step easier in the logs. The .yml editor can be a pain and overwhelming especially when you are starting with pipelines. Once you are used to it, it is way better than the old editor. Add more steps to the CI Pipeline I plan to add several new steps to restore NuGet packages, build the solution, run tests, and publish the solution. The publish step should only be run when the pipeline was triggered by the master branch. I remove the build script and select the .NET Core task on the right side. I select restore as command and **/*.csproj as the path to the projects. This will restore all available projects. Then click Add, to add the task to your pipeline. Make sure that your cursor is at the beginning of the next line under steps.   Add a Nuget restore step to the CI Pipeline I repeat the process of adding new .NET Core tasks but I use build to build all projects, test to run all projects that have Test at the end of the project name, and then publish the CustomerApi project. The whole pipeline looks as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 trigger: - master pool: vmImage: &#39;ubuntu-latest&#39; variables: buildConfiguration: &#39;Release&#39; steps: - task: DotNetCoreCLI@2 inputs: command: &#39;restore&#39; projects: &#39;**/*.csproj&#39; displayName: &#39;Restore Nuget Packages&#39; - task: DotNetCoreCLI@2 inputs: command: &#39;build&#39; projects: &#39;**/*.csproj&#39; arguments: &#39;--no-restore&#39; displayName: &#39;Build projects&#39; - task: DotNetCoreCLI@2 inputs: command: &#39;test&#39; projects: &#39;**/*Test.csproj&#39; arguments: &#39;--no-restore&#39; displayName: &#39;Run Tests&#39; - task: DotNetCoreCLI@2 inputs: command: &#39;publish&#39; publishWebProjects: false projects: &#39;**/CustomerApi.csproj&#39; arguments: &#39;--configuration $(buildConfiguration) --no-restore&#39; modifyOutputPath: false displayName: &#39;Publish CustomerApi&#39; Click Save and Run and and the pipeline will be added to your source control and then executed.I created a new branch to test if everything is fine. Running the CI Pipeline After the build is finished, you see a summary and that all 52 tests passed. All unit tests passed You don’t see anything under Code Coverage. I will cover this in a later post. Run Tasks only when the Master Branch triggered the build Currently, the publish task runs always, even if I don’t want to create a release. It would be more efficient to run this task only when the build was triggered by the master branch. To do that, I add a custom condition to the publish task. I want to run the publish only when the previous steps succeeded and when the branch name is master. I do this with the following code: 1 2 3 4 5 6 7 8 9 - task: DotNetCoreCLI@2 inputs: command: &#39;publish&#39; publishWebProjects: false projects: &#39;**/CustomerApi.csproj&#39; arguments: &#39;--configuration $(buildConfiguration) --no-restore&#39; modifyOutputPath: false displayName: &#39;Publish CustomerApi&#39; condition: and(succeeded(), eq(variables[&#39;Build.SourceBranch&#39;], &#39;refs/heads/master&#39;)) Save the pipeline and run it with any branch but the master branch. You will see that the publish task is skipped. The Publish Task got skipped Conclusion CI pipelines help developers to get fast feedback about their code changes. These pipelines can build code and run tests every time something changed. In my next post, I will show how to add code coverage to the results to get even more information about the code changes, and then I will show how to run your code with every pull request. Later, I will extend the pipeline to build and create Docker images and also to deploy them to Kubernetes. You can find the code of the demo on Github." /><meta property="og:description" content="A crucial feature of DevOps is to give the developer fast feedback if their code changes work. This can be done by automatically building code and running tests every time changes are checked-in. Today, I will show how to create a CI pipeline (continuous integration) for ASP .NET Core. Create a .NET Core CI Pipeline in Azure DevOps In my last post, Creating a Microservice with .NET Core 3.1, I created a new ASP .NET Core microservice. I will use the CI pipeline to build all projects and run all unit tests in the repository. You can find the code of the demo on Github. In your Azure DevOps project, go to Pipelines and click Create Pipeline. Create a new CI Pipeline In the next window, select where you have your code stored. I select GitHub for this Demo. Usually, I have my code directly in Azure DevOps, then I would select Azure Repos Git. On the bottom, you can see “Use the classic editor”. This opens the old task-based editor. You shouldn’t use this anymore since the new standard is to use YML pipelines. This enables you to have your pipeline in your source control. Select where your code is Authorize Github Since the code is on GitHub, I have to authorize Azure Pipelines to access my repositories. If the code was on an Azure Repos, this step wouldn’t be necessary. Authorize Azure Pipelines to access Github After authorizing Azure Pipelines for GitHub, all your repositories will be displayed. Search and select for the repository, you want to make the CI pipeline for. In my case, I select the .NetCoreMicroserviceCiCdAks repository. Select your repository On the next window, I have to approve to install Azure Pipelines in my Github repository. This allows Azure DevOps to access the repository and write to the code. This is necessary because the CI pipeline will be added to the source control. Again, this is not necessary when you have your code in Azure DevOps. Select a Template On the next step, select a template for your CI pipeline. Azure DevOps offers many templates like Docker, Kubernetes, PHP, or Node.js. Since my application is a .NET Core microservice, I select the ASP.NET Core template. Select the ASP.NET Core template for your CI Pipeline That’s it. The template created a simple CI pipeline and you can use it to build your .NET Core solution. In the next section, I will go into more detail about the functionality and add more steps. The template created a simple CI Pipeline Add more steps to the CI Pipeline Before we add more steps to the CI pipeline, let’s have a look at what the template created. Analyze the CI Pipeline from the Template Above the .yml editor, you can see the path to the pipeline yml file in your source control. In my case it is WolfgangOfner/.NetCoreMicroserviceCiCdAks/dotnetcoreCIPipeline.yml. I renamed the file because I want to add more later. Line 1 through 8 configures the pipeline. The trigger section defines that the pipeline is automatically triggered when something changes on the master branch. The pool section defines that the pipeline is executed on an ubuntu agent and the variables section lets you define variables for the pipeline. By default, only the buildConfiguration is set to Release. On line 10 starts the first build step that executes a dotnet build in sets the configuration to Release by using the previously defined buildConfiguration variable. Additionally, a display name is set to identify the step easier in the logs. The .yml editor can be a pain and overwhelming especially when you are starting with pipelines. Once you are used to it, it is way better than the old editor. Add more steps to the CI Pipeline I plan to add several new steps to restore NuGet packages, build the solution, run tests, and publish the solution. The publish step should only be run when the pipeline was triggered by the master branch. I remove the build script and select the .NET Core task on the right side. I select restore as command and **/*.csproj as the path to the projects. This will restore all available projects. Then click Add, to add the task to your pipeline. Make sure that your cursor is at the beginning of the next line under steps.   Add a Nuget restore step to the CI Pipeline I repeat the process of adding new .NET Core tasks but I use build to build all projects, test to run all projects that have Test at the end of the project name, and then publish the CustomerApi project. The whole pipeline looks as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 trigger: - master pool: vmImage: &#39;ubuntu-latest&#39; variables: buildConfiguration: &#39;Release&#39; steps: - task: DotNetCoreCLI@2 inputs: command: &#39;restore&#39; projects: &#39;**/*.csproj&#39; displayName: &#39;Restore Nuget Packages&#39; - task: DotNetCoreCLI@2 inputs: command: &#39;build&#39; projects: &#39;**/*.csproj&#39; arguments: &#39;--no-restore&#39; displayName: &#39;Build projects&#39; - task: DotNetCoreCLI@2 inputs: command: &#39;test&#39; projects: &#39;**/*Test.csproj&#39; arguments: &#39;--no-restore&#39; displayName: &#39;Run Tests&#39; - task: DotNetCoreCLI@2 inputs: command: &#39;publish&#39; publishWebProjects: false projects: &#39;**/CustomerApi.csproj&#39; arguments: &#39;--configuration $(buildConfiguration) --no-restore&#39; modifyOutputPath: false displayName: &#39;Publish CustomerApi&#39; Click Save and Run and and the pipeline will be added to your source control and then executed.I created a new branch to test if everything is fine. Running the CI Pipeline After the build is finished, you see a summary and that all 52 tests passed. All unit tests passed You don’t see anything under Code Coverage. I will cover this in a later post. Run Tasks only when the Master Branch triggered the build Currently, the publish task runs always, even if I don’t want to create a release. It would be more efficient to run this task only when the build was triggered by the master branch. To do that, I add a custom condition to the publish task. I want to run the publish only when the previous steps succeeded and when the branch name is master. I do this with the following code: 1 2 3 4 5 6 7 8 9 - task: DotNetCoreCLI@2 inputs: command: &#39;publish&#39; publishWebProjects: false projects: &#39;**/CustomerApi.csproj&#39; arguments: &#39;--configuration $(buildConfiguration) --no-restore&#39; modifyOutputPath: false displayName: &#39;Publish CustomerApi&#39; condition: and(succeeded(), eq(variables[&#39;Build.SourceBranch&#39;], &#39;refs/heads/master&#39;)) Save the pipeline and run it with any branch but the master branch. You will see that the publish task is skipped. The Publish Task got skipped Conclusion CI pipelines help developers to get fast feedback about their code changes. These pipelines can build code and run tests every time something changed. In my next post, I will show how to add code coverage to the results to get even more information about the code changes, and then I will show how to run your code with every pull request. Later, I will extend the pipeline to build and create Docker images and also to deploy them to Kubernetes. You can find the code of the demo on Github." /><link rel="canonical" href="https://www.programmingwithwolfgang.com/create-net-core-in-ci-pipeline-in-azure-devops/" /><meta property="og:url" content="https://www.programmingwithwolfgang.com/create-net-core-in-ci-pipeline-in-azure-devops/" /><meta property="og:site_name" content="Programming With Wolfgang" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-08-03T19:24:06+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Create a .NET Core CI Pipeline in Azure DevOps" /><meta name="twitter:site" content="@wolfgang_ofner" /><meta name="twitter:creator" content="@Wolfgang Ofner" /><meta name="google-site-verification" content="xxsPm-h6A0B6a0QMgqXO80PU4DbMt4Dq06p-SGzB3TU" /> <script type="application/ld+json"> {"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.programmingwithwolfgang.com/create-net-core-in-ci-pipeline-in-azure-devops/"},"author":{"@type":"Person","name":"Wolfgang Ofner"},"url":"https://www.programmingwithwolfgang.com/create-net-core-in-ci-pipeline-in-azure-devops/","description":"A crucial feature of DevOps is to give the developer fast feedback if their code changes work. This can be done by automatically building code and running tests every time changes are checked-in. Today, I will show how to create a CI pipeline (continuous integration) for ASP .NET Core. Create a .NET Core CI Pipeline in Azure DevOps In my last post, Creating a Microservice with .NET Core 3.1, I created a new ASP .NET Core microservice. I will use the CI pipeline to build all projects and run all unit tests in the repository. You can find the code of the demo on Github. In your Azure DevOps project, go to Pipelines and click Create Pipeline. Create a new CI Pipeline In the next window, select where you have your code stored. I select GitHub for this Demo. Usually, I have my code directly in Azure DevOps, then I would select Azure Repos Git. On the bottom, you can see “Use the classic editor”. This opens the old task-based editor. You shouldn’t use this anymore since the new standard is to use YML pipelines. This enables you to have your pipeline in your source control. Select where your code is Authorize Github Since the code is on GitHub, I have to authorize Azure Pipelines to access my repositories. If the code was on an Azure Repos, this step wouldn’t be necessary. Authorize Azure Pipelines to access Github After authorizing Azure Pipelines for GitHub, all your repositories will be displayed. Search and select for the repository, you want to make the CI pipeline for. In my case, I select the .NetCoreMicroserviceCiCdAks repository. Select your repository On the next window, I have to approve to install Azure Pipelines in my Github repository. This allows Azure DevOps to access the repository and write to the code. This is necessary because the CI pipeline will be added to the source control. Again, this is not necessary when you have your code in Azure DevOps. Select a Template On the next step, select a template for your CI pipeline. Azure DevOps offers many templates like Docker, Kubernetes, PHP, or Node.js. Since my application is a .NET Core microservice, I select the ASP.NET Core template. Select the ASP.NET Core template for your CI Pipeline That’s it. The template created a simple CI pipeline and you can use it to build your .NET Core solution. In the next section, I will go into more detail about the functionality and add more steps. The template created a simple CI Pipeline Add more steps to the CI Pipeline Before we add more steps to the CI pipeline, let’s have a look at what the template created. Analyze the CI Pipeline from the Template Above the .yml editor, you can see the path to the pipeline yml file in your source control. In my case it is WolfgangOfner/.NetCoreMicroserviceCiCdAks/dotnetcoreCIPipeline.yml. I renamed the file because I want to add more later. Line 1 through 8 configures the pipeline. The trigger section defines that the pipeline is automatically triggered when something changes on the master branch. The pool section defines that the pipeline is executed on an ubuntu agent and the variables section lets you define variables for the pipeline. By default, only the buildConfiguration is set to Release. On line 10 starts the first build step that executes a dotnet build in sets the configuration to Release by using the previously defined buildConfiguration variable. Additionally, a display name is set to identify the step easier in the logs. The .yml editor can be a pain and overwhelming especially when you are starting with pipelines. Once you are used to it, it is way better than the old editor. Add more steps to the CI Pipeline I plan to add several new steps to restore NuGet packages, build the solution, run tests, and publish the solution. The publish step should only be run when the pipeline was triggered by the master branch. I remove the build script and select the .NET Core task on the right side. I select restore as command and **/*.csproj as the path to the projects. This will restore all available projects. Then click Add, to add the task to your pipeline. Make sure that your cursor is at the beginning of the next line under steps.   Add a Nuget restore step to the CI Pipeline I repeat the process of adding new .NET Core tasks but I use build to build all projects, test to run all projects that have Test at the end of the project name, and then publish the CustomerApi project. The whole pipeline looks as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 trigger: - master pool: vmImage: &#39;ubuntu-latest&#39; variables: buildConfiguration: &#39;Release&#39; steps: - task: DotNetCoreCLI@2 inputs: command: &#39;restore&#39; projects: &#39;**/*.csproj&#39; displayName: &#39;Restore Nuget Packages&#39; - task: DotNetCoreCLI@2 inputs: command: &#39;build&#39; projects: &#39;**/*.csproj&#39; arguments: &#39;--no-restore&#39; displayName: &#39;Build projects&#39; - task: DotNetCoreCLI@2 inputs: command: &#39;test&#39; projects: &#39;**/*Test.csproj&#39; arguments: &#39;--no-restore&#39; displayName: &#39;Run Tests&#39; - task: DotNetCoreCLI@2 inputs: command: &#39;publish&#39; publishWebProjects: false projects: &#39;**/CustomerApi.csproj&#39; arguments: &#39;--configuration $(buildConfiguration) --no-restore&#39; modifyOutputPath: false displayName: &#39;Publish CustomerApi&#39; Click Save and Run and and the pipeline will be added to your source control and then executed.I created a new branch to test if everything is fine. Running the CI Pipeline After the build is finished, you see a summary and that all 52 tests passed. All unit tests passed You don’t see anything under Code Coverage. I will cover this in a later post. Run Tasks only when the Master Branch triggered the build Currently, the publish task runs always, even if I don’t want to create a release. It would be more efficient to run this task only when the build was triggered by the master branch. To do that, I add a custom condition to the publish task. I want to run the publish only when the previous steps succeeded and when the branch name is master. I do this with the following code: 1 2 3 4 5 6 7 8 9 - task: DotNetCoreCLI@2 inputs: command: &#39;publish&#39; publishWebProjects: false projects: &#39;**/CustomerApi.csproj&#39; arguments: &#39;--configuration $(buildConfiguration) --no-restore&#39; modifyOutputPath: false displayName: &#39;Publish CustomerApi&#39; condition: and(succeeded(), eq(variables[&#39;Build.SourceBranch&#39;], &#39;refs/heads/master&#39;)) Save the pipeline and run it with any branch but the master branch. You will see that the publish task is skipped. The Publish Task got skipped Conclusion CI pipelines help developers to get fast feedback about their code changes. These pipelines can build code and run tests every time something changed. In my next post, I will show how to add code coverage to the results to get even more information about the code changes, and then I will show how to run your code with every pull request. Later, I will extend the pipeline to build and create Docker images and also to deploy them to Kubernetes. You can find the code of the demo on Github.","@type":"BlogPosting","headline":"Create a .NET Core CI Pipeline in Azure DevOps","dateModified":"2020-12-30T18:43:38+01:00","datePublished":"2020-08-03T19:24:06+02:00","@context":"https://schema.org"}</script><title>Create a .NET Core CI Pipeline in Azure DevOps | Programming With Wolfgang</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="preload" href="/assets/css/post.css" as="style"><link rel="stylesheet" href="/assets/css/post.css"><link rel="preload" as="style" href="/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/css/lib/bootstrap-toc.min.css" /> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="/assets/js/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-112077092-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-112077092-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/author/wolfgang-small.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Programming With Wolfgang</a></div><div class="site-subtitle font-italic">Let's talk programming</div></div><div class="w-100 d-flex justify-content-center"> <i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span></div><ul class="w-100" style="margin-top: 1em;"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tabs/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tabs/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/tabs/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/tabs/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/wolfgangofner" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/wolfgang_ofner" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href="https://www.linkedin.com/in/wolfgangofner" aria-label="linkedin" class="order-5" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['wolfgang','programmingwithwolfgang.com'].join('@')" aria-label="email" class="order-6" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-7" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="d-sm-none row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Create a .NET Core CI Pipeline in Azure DevOps</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Create a .NET Core CI Pipeline in Azure DevOps</div><div style="visibility:hidden;"> <i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel">Cancel</span></div></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Create a .NET Core CI Pipeline in Azure DevOps</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Mon, Aug 3, 2020, 7:24 PM +0200" > Aug 3, 2020 <i class="unloaded">2020-08-03T19:24:06+02:00</i> </span> by <span class="author"> Wolfgang Ofner </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Wed, Dec 30, 2020, 6:43 PM +0100" > Dec 30, 2020 <i class="unloaded">2020-12-30T18:43:38+01:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1178 words">13 min</span></div></div><div class="post-content"><p>A crucial feature of DevOps is to give the developer fast feedback if their code changes work. This can be done by automatically building code and running tests every time changes are checked-in. Today, I will show how to create a CI pipeline (continuous integration) for ASP .NET Core.</p><h2 id="create-a-net-core-ci-pipeline-in-azure-devops">Create a .NET Core CI Pipeline in Azure DevOps</h2><p>In my <a href="/creating-a-microservice-with-net-core-3-1/" target="_blank" rel="noopener noreferrer">last post, Creating a Microservice with .NET Core 3.1</a>, I created a new ASP .NET Core microservice. I will use the CI pipeline to build all projects and run all unit tests in the repository. You can find the code of the demo on <a href="https://github.com/WolfgangOfner/.NetCoreMicroserviceCiCdAks/tree/NetCoreCiPipeline" target="_blank" rel="noopener noreferrer">Github</a>.</p><p>In your Azure DevOps project, go to Pipelines and click Create Pipeline.</p><div class="col-12 col-sm-10 aligncenter"> <a href="/assets/img/posts/2020/08/Create-a-new-CI-Pipeline.jpg"><img loading="lazy" src="/assets/img/posts/2020/08/Create-a-new-CI-Pipeline.jpg" alt="Create a new CI Pipeline" /></a><p> Create a new CI Pipeline</p></div><p>In the next window, select where you have your code stored. I select GitHub for this Demo. Usually, I have my code directly in Azure DevOps, then I would select Azure Repos Git. On the bottom, you can see “Use the classic editor”. This opens the old task-based editor. You shouldn’t use this anymore since the new standard is to use YML pipelines. This enables you to have your pipeline in your source control.</p><div class="col-12 col-sm-10 aligncenter"> <a href="/assets/img/posts/2020/08/Select-where-your-code-is.jpg"><img loading="lazy" src="/assets/img/posts/2020/08/Select-where-your-code-is.jpg" alt="Select where your code is" /></a><p> Select where your code is</p></div><h3 id="authorize-github">Authorize Github</h3><p>Since the code is on GitHub, I have to authorize Azure Pipelines to access my repositories. If the code was on an Azure Repos, this step wouldn’t be necessary.</p><div class="col-12 col-sm-10 aligncenter"> <a href="/assets/img/posts/2020/08/Authorize-Azure-Pipelines-to-access-Github.jpg"><img loading="lazy" src="/assets/img/posts/2020/08/Authorize-Azure-Pipelines-to-access-Github.jpg" alt="Authorize Azure Pipelines to access Github" /></a><p> Authorize Azure Pipelines to access Github</p></div><p>After authorizing Azure Pipelines for GitHub, all your repositories will be displayed. Search and select for the repository, you want to make the CI pipeline for. In my case, I select the .NetCoreMicroserviceCiCdAks repository.</p><div class="col-12 col-sm-10 aligncenter"> <a href="/assets/img/posts/2020/10/Select-your-repository.jpg"><img loading="lazy" src="/assets/img/posts/2020/10/Select-your-repository.jpg" alt="Select your repository" /></a><p> Select your repository</p></div><p>On the next window, I have to approve to install Azure Pipelines in my Github repository. This allows Azure DevOps to access the repository and write to the code. This is necessary because the CI pipeline will be added to the source control. Again, this is not necessary when you have your code in Azure DevOps.</p><h3 id="select-a-template">Select a Template</h3><p>On the next step, select a template for your CI pipeline. Azure DevOps offers many templates like Docker, Kubernetes, PHP, or Node.js. Since my application is a .NET Core microservice, I select the ASP.NET Core template.</p><div class="col-12 col-sm-10 aligncenter"> <a href="/assets/img/posts/2020/08/Select-the-ASP.NET-Core-template-for-your-CI-Pipeline.jpg"><img loading="lazy" src="/assets/img/posts/2020/08/Select-the-ASP.NET-Core-template-for-your-CI-Pipeline.jpg" alt="Select the ASP.NET Core template for your CI Pipeline" /></a><p> Select the ASP.NET Core template for your CI Pipeline</p></div><p>That’s it. The template created a simple CI pipeline and you can use it to build your .NET Core solution. In the next section, I will go into more detail about the functionality and add more steps.</p><div class="col-12 col-sm-10 aligncenter"> <a href="/assets/img/posts/2020/10/The-template-created-a-simple-CI-Pipeline.jpg"><img loading="lazy" src="/assets/img/posts/2020/10/The-template-created-a-simple-CI-Pipeline.jpg" alt="The template created a simple CI Pipeline" /></a><p> The template created a simple CI Pipeline</p></div><h2 id="add-more-steps-to-the-ci-pipeline">Add more steps to the CI Pipeline</h2><p>Before we add more steps to the CI pipeline, let’s have a look at what the template created.</p><h3 id="analyze-the-ci-pipeline-from-the-template">Analyze the CI Pipeline from the Template</h3><p>Above the .yml editor, you can see the path to the pipeline yml file in your source control. In my case it is WolfgangOfner/.NetCoreMicroserviceCiCdAks/dotnetcoreCIPipeline.yml. I renamed the file because I want to add more later.</p><p>Line 1 through 8 configures the pipeline. The trigger section defines that the pipeline is automatically triggered when something changes on the master branch. The pool section defines that the pipeline is executed on an ubuntu agent and the variables section lets you define variables for the pipeline. By default, only the buildConfiguration is set to Release.</p><p>On line 10 starts the first build step that executes a dotnet build in sets the configuration to Release by using the previously defined buildConfiguration variable. Additionally, a display name is set to identify the step easier in the logs.</p><p>The .yml editor can be a pain and overwhelming especially when you are starting with pipelines. Once you are used to it, it is way better than the old editor.</p><h3 id="add-more-steps-to-the-ci-pipeline-1">Add more steps to the CI Pipeline</h3><p>I plan to add several new steps to restore NuGet packages, build the solution, run tests, and publish the solution. The publish step should only be run when the pipeline was triggered by the master branch.</p><p>I remove the build script and select the .NET Core task on the right side. I select restore as command and **/*.csproj as the path to the projects. This will restore all available projects. Then click Add, to add the task to your pipeline. Make sure that your cursor is at the beginning of the next line under steps.</p><p> </p><div class="col-12 col-sm-10 aligncenter"> <a href="/assets/img/posts/2020/10/Add-a-Nuget-restore-step-to-the-CI-Pipeline.jpg"><img loading="lazy" src="/assets/img/posts/2020/10/Add-a-Nuget-restore-step-to-the-CI-Pipeline.jpg" alt="Add a Nuget restore step to the CI Pipeline" /></a><p> Add a Nuget restore step to the CI Pipeline</p></div><p>I repeat the process of adding new .NET Core tasks but I use build to build all projects, test to run all projects that have Test at the end of the project name, and then publish the CustomerApi project. The whole pipeline looks as follows:</p><div class="language-yaml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="na">trigger</span><span class="pi">:</span>
<span class="pi">-</span> <span class="s">master</span>
 
<span class="na">pool</span><span class="pi">:</span>
  <span class="na">vmImage</span><span class="pi">:</span> <span class="s1">'</span><span class="s">ubuntu-latest'</span>
 
<span class="na">variables</span><span class="pi">:</span>
  <span class="na">buildConfiguration</span><span class="pi">:</span> <span class="s1">'</span><span class="s">Release'</span>
 
<span class="na">steps</span><span class="pi">:</span>
<span class="pi">-</span> <span class="na">task</span><span class="pi">:</span> <span class="s">DotNetCoreCLI@2</span>
  <span class="na">inputs</span><span class="pi">:</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s1">'</span><span class="s">restore'</span>
    <span class="na">projects</span><span class="pi">:</span> <span class="s1">'</span><span class="s">**/*.csproj'</span>
  <span class="na">displayName</span><span class="pi">:</span> <span class="s1">'</span><span class="s">Restore</span><span class="nv"> </span><span class="s">Nuget</span><span class="nv"> </span><span class="s">Packages'</span>
 
<span class="pi">-</span> <span class="na">task</span><span class="pi">:</span> <span class="s">DotNetCoreCLI@2</span>
  <span class="na">inputs</span><span class="pi">:</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s1">'</span><span class="s">build'</span>
    <span class="na">projects</span><span class="pi">:</span> <span class="s1">'</span><span class="s">**/*.csproj'</span>
    <span class="na">arguments</span><span class="pi">:</span> <span class="s1">'</span><span class="s">--no-restore'</span>
  <span class="na">displayName</span><span class="pi">:</span> <span class="s1">'</span><span class="s">Build</span><span class="nv"> </span><span class="s">projects'</span>
 
<span class="pi">-</span> <span class="na">task</span><span class="pi">:</span> <span class="s">DotNetCoreCLI@2</span>
  <span class="na">inputs</span><span class="pi">:</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s1">'</span><span class="s">test'</span>
    <span class="na">projects</span><span class="pi">:</span> <span class="s1">'</span><span class="s">**/*Test.csproj'</span>
    <span class="na">arguments</span><span class="pi">:</span> <span class="s1">'</span><span class="s">--no-restore'</span>
  <span class="na">displayName</span><span class="pi">:</span> <span class="s1">'</span><span class="s">Run</span><span class="nv"> </span><span class="s">Tests'</span>
 
<span class="pi">-</span> <span class="na">task</span><span class="pi">:</span> <span class="s">DotNetCoreCLI@2</span>
  <span class="na">inputs</span><span class="pi">:</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s1">'</span><span class="s">publish'</span>
    <span class="na">publishWebProjects</span><span class="pi">:</span> <span class="no">false</span>
    <span class="na">projects</span><span class="pi">:</span> <span class="s1">'</span><span class="s">**/CustomerApi.csproj'</span>
    <span class="na">arguments</span><span class="pi">:</span> <span class="s1">'</span><span class="s">--configuration</span><span class="nv"> </span><span class="s">$(buildConfiguration)</span><span class="nv"> </span><span class="s">--no-restore'</span>
    <span class="na">modifyOutputPath</span><span class="pi">:</span> <span class="no">false</span>
  <span class="na">displayName</span><span class="pi">:</span> <span class="s1">'</span><span class="s">Publish</span><span class="nv"> </span><span class="s">CustomerApi'</span>
</pre></table></code></div></div><p>Click Save and Run and and the pipeline will be added to your source control and then executed.I created a new branch to test if everything is fine.</p><div class="col-12 col-sm-10 aligncenter"> <a href="/assets/img/posts/2020/10/Running-the-CI-Pipeline.jpg"><img loading="lazy" src="/assets/img/posts/2020/10/Running-the-CI-Pipeline.jpg" alt="Running the CI Pipeline" /></a><p> Running the CI Pipeline</p></div><p>After the build is finished, you see a summary and that all 52 tests passed.</p><div class="col-12 col-sm-10 aligncenter"> <a href="/assets/img/posts/2020/10/All-unit-tests-passed.jpg"><img loading="lazy" src="/assets/img/posts/2020/10/All-unit-tests-passed.jpg" alt="All unit tests passed" /></a><p> All unit tests passed</p></div><p>You don’t see anything under Code Coverage. I will cover this in a later post.</p><h3 id="run-tasks-only-when-the-master-branch-triggered-the-build">Run Tasks only when the Master Branch triggered the build</h3><p>Currently, the publish task runs always, even if I don’t want to create a release. It would be more efficient to run this task only when the build was triggered by the master branch. To do that, I add a custom condition to the publish task. I want to run the publish only when the previous steps succeeded and when the branch name is master. I do this with the following code:</p><div class="language-yaml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="pi">-</span> <span class="na">task</span><span class="pi">:</span> <span class="s">DotNetCoreCLI@2</span>
  <span class="na">inputs</span><span class="pi">:</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s1">'</span><span class="s">publish'</span>
    <span class="na">publishWebProjects</span><span class="pi">:</span> <span class="no">false</span>
    <span class="na">projects</span><span class="pi">:</span> <span class="s1">'</span><span class="s">**/CustomerApi.csproj'</span>
    <span class="na">arguments</span><span class="pi">:</span> <span class="s1">'</span><span class="s">--configuration</span><span class="nv"> </span><span class="s">$(buildConfiguration)</span><span class="nv"> </span><span class="s">--no-restore'</span>
    <span class="na">modifyOutputPath</span><span class="pi">:</span> <span class="no">false</span>    
  <span class="na">displayName</span><span class="pi">:</span> <span class="s1">'</span><span class="s">Publish</span><span class="nv"> </span><span class="s">CustomerApi'</span>
  <span class="na">condition</span><span class="pi">:</span> <span class="s">and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))</span> 
</pre></table></code></div></div><p>Save the pipeline and run it with any branch but the master branch. You will see that the publish task is skipped.</p><div class="col-12 col-sm-10 aligncenter"> <a href="/assets/img/posts/2020/08/The-Publish-Task-got-skipped.jpg"><img loading="lazy" src="/assets/img/posts/2020/08/The-Publish-Task-got-skipped.jpg" alt="The Publish Task got skipped" /></a><p> The Publish Task got skipped</p></div><h2 id="conclusion">Conclusion</h2><p>CI pipelines help developers to get fast feedback about their code changes. These pipelines can build code and run tests every time something changed. In my next post, I will show how to add code coverage to the results to get even more information about the code changes, and then I will show how to run your code with every pull request. Later, I will extend the pipeline to build and create Docker images and also to deploy them to Kubernetes.</p><p>You can find the code of the demo on <a href="https://github.com/WolfgangOfner/.NetCoreMicroserviceCiCdAks/tree/NetCoreCiPipeline" target="_blank" rel="noopener noreferrer">Github</a>.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/devops/'>DevOps</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/net-core/" class="post-tag no-text-decoration" >NET Core</a> <a href="/tags/azure-devops/" class="post-tag no-text-decoration" >Azure DevOps</a> <a href="/tags/ci/" class="post-tag no-text-decoration" >CI</a> <a href="/tags/continuous-integration/" class="post-tag no-text-decoration" >Continuous Integration</a> <a href="/tags/devops/" class="post-tag no-text-decoration" >DevOps</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Create a .NET Core CI Pipeline in Azure DevOps - Programming With Wolfgang&url=https://www.programmingwithwolfgang.com/create-net-core-in-ci-pipeline-in-azure-devops/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Create a .NET Core CI Pipeline in Azure DevOps - Programming With Wolfgang&u=https://www.programmingwithwolfgang.com/create-net-core-in-ci-pipeline-in-azure-devops/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Create a .NET Core CI Pipeline in Azure DevOps - Programming With Wolfgang&url=https://www.programmingwithwolfgang.com/create-net-core-in-ci-pipeline-in-azure-devops/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://www.programmingwithwolfgang.com/create-net-core-in-ci-pipeline-in-azure-devops/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/microservice-series-from-zero-to-hero/">Microservice Series - From Zero to Hero</a><li><a href="/azure-kubernetes-service-getting-started/">Azure Kubernetes Service - Getting Started</a><li><a href="/analyze-software-architecture-ndepend/">Analyze Software Architecture with NDepend</a><li><a href="/automatically-deploy-database-changes/">Automatically deploy Database Changes with SSDT</a><li><a href="/helm-getting-started/">Helm - Getting Started</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/c/">C#</a> <a class="post-tag" href="/tags/azure/">Azure</a> <a class="post-tag" href="/tags/learning/">Learning</a> <a class="post-tag" href="/tags/azure-devops/">Azure DevOps</a> <a class="post-tag" href="/tags/docker/">Docker</a> <a class="post-tag" href="/tags/70-532/">70-532</a> <a class="post-tag" href="/tags/certification/">Certification</a> <a class="post-tag" href="/tags/exam/">Exam</a> <a class="post-tag" href="/tags/net-core/">NET Core</a> <a class="post-tag" href="/tags/ci/">CI</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/build-net-core-in-ci-pipeline-in-azure-devops/"><div class="card-body"> <span class="timeago small" > Oct 13, 2020 <i class="unloaded">2020-10-13T17:20:53+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Build .NET Core in a CI Pipeline in Azure DevOps</h3><div class="text-muted small"><p> A crucial feature of DevOps is to give the developer fast feedback if their code changes work. This can be done by automatically building code and running tests every time changes are checked-in. T...</p></div></div></a></div><div class="card"> <a href="/create-a-docker-image-in-an-azure-devops-ci-pipeline/"><div class="card-body"> <span class="timeago small" > Sep 14, 2020 <i class="unloaded">2020-09-14T14:34:59+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Create a Docker Image in an Azure DevOps CI Pipeline</h3><div class="text-muted small"><p> In my last post, I showed how to build a .NET Core Microservice inside a Docker container. Today, I want to build this microservice in an Azure DevOps CI pipeline and push the image to Docker Hub. ...</p></div></div></a></div><div class="card"> <a href="/run-the-ci-pipeline-during-pull-request/"><div class="card-body"> <span class="timeago small" > Oct 17, 2020 <i class="unloaded">2020-10-17T16:34:44+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Run the CI Pipeline during a Pull Request</h3><div class="text-muted small"><p> In the modern DevOps culture, the goal is to get features as fast as possible into production. Additionally, we have to guarantee that these new features don’t break anything. To do that, I will sh...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/create-a-net-core-visual-studio-template/" class="btn btn-outline-primary"><p>Create a .NET Core Visual Studio Template</p></a> <a href="/add-docker-to-a-asp-net-core-microservice/" class="btn btn-outline-primary"><p>Add Docker to an ASP .NET Core Microservice</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="font-italic text-center text-muted small"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> var options = { scriptUrl: '//programmingwithwolfgang.disqus.com/embed.js', disqusConfig: function() { this.page.url = 'https://www.programmingwithwolfgang.com/create-net-core-in-ci-pipeline-in-azure-devops/'; this.page.identifier = '/create-net-core-in-ci-pipeline-in-azure-devops/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://twitter.com/wolfgang_ofner">Wolfgang Ofner</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy/" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/c/">C#</a> <a class="post-tag" href="/tags/azure/">Azure</a> <a class="post-tag" href="/tags/learning/">Learning</a> <a class="post-tag" href="/tags/azure-devops/">Azure DevOps</a> <a class="post-tag" href="/tags/docker/">Docker</a> <a class="post-tag" href="/tags/70-532/">70 532</a> <a class="post-tag" href="/tags/certification/">Certification</a> <a class="post-tag" href="/tags/exam/">Exam</a> <a class="post-tag" href="/tags/net-core/">NET Core</a> <a class="post-tag" href="/tags/ci/">CI</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.programmingwithwolfgang.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>

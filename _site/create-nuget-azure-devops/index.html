<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="theme" content="Chirpy v2.7.2"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="Create NuGet Packages in Azure DevOps Pipelines" /><meta name="author" content="Wolfgang Ofner" /><meta property="og:locale" content="en_US" /><meta name="description" content="I think the most important rule of a microservice is that it has to be deployed independently. When your project or company grows, it is very likely that you want to share code between projects or microservices. This leads to the question of how to share the code? Should you copy it into your microservice, reference dlls, or should every team develop its own code independently? In this post, I will show how to share code using NuGet packages and how to automatically create them in an Azure DevOps pipeline. How to share Code between Microservices There are several methods of sharing code between microservices but I think most of them are bad. Let’s have a look at the available options. Don’t share Code Not sharing code between microservices helps to keep them independent but this means that each microservice must develop all features by itself. This can lead to a lot of unnecessary development time and therefore costs a lot of money. Therefore, not sharing code is not an option. Referencing Dlls I prefer having all microservices in a big repository. This allows you to reference code from a different project. You could create a Shared folder and create in there projects which are shared between several microservices. The problem with this approach is that when one team changes the code, it changes the code for all microservices that reference the code. This will certainly lead to unintended and unexpected behavior. Since we want bug-free code, this option is not good to share code. Create Code and then copy it to Microservices Another option would be to create a new project with the code and use this code as the base for further developments. If a microservice wants to use this code, then copy it into their own project and then can edit it without interfering with other microservices. This solution sounds better than the previous one but this leads to a lot of overhead. All these versions will go in different directions, therefore it will take a lot of time to do simple changes, for example, updating the .NET version of the project. This has to be done in each implementation instead of in one central one. Therefore this solution is also not good. Share Code with NuGet Packages If you want to get external code and have control over it, NuGet packages are perfect. You can install the version you need and also can update whenever you have to. If the NuGet package gets updated but you don’t want to update yours, it’s no problem at all. The source code of the NuGet package exists only once, therefore it can be updated or modified quickly. Once a new version is released, every microservice can update it whenever they want. Create the Source for the NuGet Package You can find the code of the whole demo on Github. For this Demo, I will create a simple NuGet package that offers one method which takes an integer and then calculates a prime number, depending on the input. Prime numbers are, for example, 2, 3, 5, 7, 11, and so on. The input parameter indicates the number you want, for example, if you input 2, the second prime number, 3, is returned. If you input 4, the fourth prime number, 7 is returned. I know this is not going to be the most useful NuGet package but calculating prime numbers is quite CPU intensive and I will use this method in a later example to demonstrate autoscaling if the CPU limit is reached. I created a new folder in the root of my repository and called it NuGet. Inside this folder, I created a new folder called Prime Number which contains a new .NET 5 class library project. The class library consists only of one class with one method to calculate the prime number. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 public static class PrimeNumber { /// &lt;summary&gt; /// Provide a parameter nThPrimeNumber and find the nThPrimeNumber-th prime number. /// &lt;/summary&gt; /// &lt;param name=&quot;nThPrimeNumber&quot;&gt;The nThPrimeNumber-th prime number to find.&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static long FindNthPrimeNumber(int nThPrimeNumber) { var count = 0; long a = 2; while (count &lt; nThPrimeNumber) { long b = 2; var prime = 1; while (b * b &lt;= a) { if (a % b == 0) { prime = 0; break; } b++; } if (prime &gt; 0) { count++; } a++; } return --a; } } To make sure that the code does what I expect it to do, I created a test project to test it. 1 2 3 4 5 6 7 8 9 10 11 12 13 public class PrimeNumberTests { [Theory] [InlineData(3, 5)] [InlineData(5, 11)] [InlineData(50, 229)] public void FindNthPrimeNumber(int nThPrimeNumber, int expectedResult) { var result = PrimeNumber.FindNthPrimeNumber(nThPrimeNumber) result.Should().Be(expectedResult); } } That’s already all the code you need for the NuGet package. You could create the NuGet package manually by executing nuget pack in the root folder of the project but in the next section, I will show you how to create it automatically in an Azure DevOps pipeline. Create NuGet Package in Azure DevOps Pipeline I created a new pipeline in Azure DevOps to create the NuGet package. For more information about the basics of build pipelines read my post Build .NET Core in a CI Pipeline in Azure DevOps. The pipeline is going to be very simple but let’s have a look step-by-step. The first part is configuring when the pipeline should run, what agent it uses, and two variables. I run the pipeline every time something is changed inside the NuGet folder, except if it’s inside a Test folder. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 name : NuGet-CI-CD trigger: branches: include: - master paths: include: - NuGet/* exclude: - NuGet/**/*.Test pool: vmImage: &#39;ubuntu-latest&#39; variables: BuildConfiguration: Release ArtifactNuGetName: &#39;packages-nuget&#39; The next section defines a stage called build and creates a version number. If you want to learn more about the build versioning see Automatically Version Docker Containers in Azure DevOps CI. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 stages: - stage: build displayName: &#39;Build NuGet Package&#39; jobs: - job: CI_Build displayName: &#39;NuGet - Build, Pack and Test&#39; steps: - task: BuildVersioning@0 displayName: &#39;Build Versioning&#39; inputs: versionSource: &#39;gitversion&#39; doInstallGitVersion: true GitVersionInstallerSource: &#39;choco&#39; GitVersionInstallerVersion: &#39;5.0.1&#39; doUseLatestGitVersionInstallerVersion: false paramAssemblyVersion: &#39;7&#39; paramAssemblyFileVersion: &#39;7&#39; paramAssemblyInformationalVersion: &#39;6&#39; paramOverwriteFourthDigitWithBuildCounter: false paramVersionCode: &#39;2&#39; doAssemblyInfoAppendSuffix: false doConvertAssemblyInfoToLowerCase: true buildNumberVersionFormat: &#39;3&#39; buildNumberAction: &#39;replace&#39; doReplaceAssemblyInfo: false doReplaceNuspec: false doReplaceNpm: false doReplaceDotNetCore: true filePatternDotNetCore: | **\*.csproj **\*.props paramDotNetCoreVersionType: &#39;3&#39; doReplaceAndroid: false doReplaceiOS: false doReplaceCustom: false doShowWarningsForUnmatchedRegex: false excludeFilePattern: | !**/bin/** !**/obj/** !**/node_modules/** !**/packages/** After the version number is calculated, I execute dotnet restore and then dotnet build on all csproj files inside the NuGet folder. 1 2 3 4 5 6 7 8 9 10 11 12 13 - task: DotNetCoreCLI@2 displayName: &#39;Restore packages&#39; inputs: command: &#39;restore&#39; projects: &#39;NuGet/**/*.csproj&#39; feedsToUse: &#39;select&#39; - task: DotNetCoreCLI@2 displayName: &#39;Build solution&#39; inputs: command: &#39;build&#39; projects: &#39;NuGet/**/*.csproj&#39; arguments: &#39;-c $(BuildConfiguration) --no-restore&#39; The next step is to run the unit tests and publish the code coverage results. If a test fails, I will stop the pipeline and don’t create the NuGet package. 1 2 3 4 5 6 7 8 9 10 11 12 13 - task: DotNetCoreCLI@2 displayName: Run tests inputs: command: &#39;test&#39; projects: &#39;NuGet/**/*.Test.csproj&#39; arguments: &#39;-c $(BuildConfiguration) --no-build /p:CollectCoverage=true /p:CoverletOutputFormat=cobertura /p:CoverletOutput=$(Build.SourcesDirectory)/TestResults/Coverage/&#39; publishTestResults: true - task: PublishCodeCoverageResults@1 displayName: &#39;Publish code coverage report&#39; inputs: codeCoverageTool: &#39;Cobertura&#39; summaryFileLocation: &#39;$(Build.SourcesDirectory)/**/coverage.cobertura.xml&#39; The last two tasks create the NuGet package using dotnet pack and then publish the generate artifacts. Dotnet pack is executed on all project files inside the NuGet folder which don’t end with Test.csproj. This means that the test project doesn’t get packed into a NuGet package. The publish of the artifacts will be used in the next stage to publish the artifact to a private NuGet feed and in another stage to publish it to nuget.org. You can read about publishing in my next post. 1 2 3 4 5 6 7 8 9 10 11 12 13 - task: DotNetCoreCLI@2 displayName: &#39;Create nuget packages&#39; inputs: command: &#39;pack&#39; packagesToPack: &#39;NuGet/**/*.csproj;!**/*.Test.csproj&#39; packDirectory: &#39;$(Build.ArtifactStagingDirectory)/packages/nuget&#39; nobuild: true versioningScheme: &#39;byBuildNumber&#39; - publish: &#39;$(Build.ArtifactStagingDirectory)/packages/nuget&#39; displayName: &#39;Publish Artifact: $(ArtifactNuGetName)&#39; artifact: &#39;packages-nuget&#39; condition: and(succeeded(), ne(variables[&#39;Build.Reason&#39;], &#39;PullRequest&#39;)) You can find the finished pipeline on Github. Test the NuGet from the Pipeline Run the pipeline and after it is finished successfully, you can find the NuGet package as an attachment of the build. In your build click on 2 published. Find the NuGet package in the build Open the packages-nuget folder and there you can find the created NuGet package. The created NuGet package Download it and install it in your microservice. In my next post, I will show you how to automatically upload it to a NuGet feed in the Azure DevOps pipeline and how to install it from there. Conclusion Sharing code between microservices can be tricky but with NuGet packages, it is very simple and organized. In this post, I showed you how to automatically create a NuGet package using Azure DevOps pipelines. In my next post, I will show how to upload the NuGet package to a NuGet feed with the same Azure DevOps pipeline and how to use it in your microservices. You can find the code of the whole demo on Github. This post is part of “Microservice Series - From Zero to Hero”." /><meta property="og:description" content="I think the most important rule of a microservice is that it has to be deployed independently. When your project or company grows, it is very likely that you want to share code between projects or microservices. This leads to the question of how to share the code? Should you copy it into your microservice, reference dlls, or should every team develop its own code independently? In this post, I will show how to share code using NuGet packages and how to automatically create them in an Azure DevOps pipeline. How to share Code between Microservices There are several methods of sharing code between microservices but I think most of them are bad. Let’s have a look at the available options. Don’t share Code Not sharing code between microservices helps to keep them independent but this means that each microservice must develop all features by itself. This can lead to a lot of unnecessary development time and therefore costs a lot of money. Therefore, not sharing code is not an option. Referencing Dlls I prefer having all microservices in a big repository. This allows you to reference code from a different project. You could create a Shared folder and create in there projects which are shared between several microservices. The problem with this approach is that when one team changes the code, it changes the code for all microservices that reference the code. This will certainly lead to unintended and unexpected behavior. Since we want bug-free code, this option is not good to share code. Create Code and then copy it to Microservices Another option would be to create a new project with the code and use this code as the base for further developments. If a microservice wants to use this code, then copy it into their own project and then can edit it without interfering with other microservices. This solution sounds better than the previous one but this leads to a lot of overhead. All these versions will go in different directions, therefore it will take a lot of time to do simple changes, for example, updating the .NET version of the project. This has to be done in each implementation instead of in one central one. Therefore this solution is also not good. Share Code with NuGet Packages If you want to get external code and have control over it, NuGet packages are perfect. You can install the version you need and also can update whenever you have to. If the NuGet package gets updated but you don’t want to update yours, it’s no problem at all. The source code of the NuGet package exists only once, therefore it can be updated or modified quickly. Once a new version is released, every microservice can update it whenever they want. Create the Source for the NuGet Package You can find the code of the whole demo on Github. For this Demo, I will create a simple NuGet package that offers one method which takes an integer and then calculates a prime number, depending on the input. Prime numbers are, for example, 2, 3, 5, 7, 11, and so on. The input parameter indicates the number you want, for example, if you input 2, the second prime number, 3, is returned. If you input 4, the fourth prime number, 7 is returned. I know this is not going to be the most useful NuGet package but calculating prime numbers is quite CPU intensive and I will use this method in a later example to demonstrate autoscaling if the CPU limit is reached. I created a new folder in the root of my repository and called it NuGet. Inside this folder, I created a new folder called Prime Number which contains a new .NET 5 class library project. The class library consists only of one class with one method to calculate the prime number. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 public static class PrimeNumber { /// &lt;summary&gt; /// Provide a parameter nThPrimeNumber and find the nThPrimeNumber-th prime number. /// &lt;/summary&gt; /// &lt;param name=&quot;nThPrimeNumber&quot;&gt;The nThPrimeNumber-th prime number to find.&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static long FindNthPrimeNumber(int nThPrimeNumber) { var count = 0; long a = 2; while (count &lt; nThPrimeNumber) { long b = 2; var prime = 1; while (b * b &lt;= a) { if (a % b == 0) { prime = 0; break; } b++; } if (prime &gt; 0) { count++; } a++; } return --a; } } To make sure that the code does what I expect it to do, I created a test project to test it. 1 2 3 4 5 6 7 8 9 10 11 12 13 public class PrimeNumberTests { [Theory] [InlineData(3, 5)] [InlineData(5, 11)] [InlineData(50, 229)] public void FindNthPrimeNumber(int nThPrimeNumber, int expectedResult) { var result = PrimeNumber.FindNthPrimeNumber(nThPrimeNumber) result.Should().Be(expectedResult); } } That’s already all the code you need for the NuGet package. You could create the NuGet package manually by executing nuget pack in the root folder of the project but in the next section, I will show you how to create it automatically in an Azure DevOps pipeline. Create NuGet Package in Azure DevOps Pipeline I created a new pipeline in Azure DevOps to create the NuGet package. For more information about the basics of build pipelines read my post Build .NET Core in a CI Pipeline in Azure DevOps. The pipeline is going to be very simple but let’s have a look step-by-step. The first part is configuring when the pipeline should run, what agent it uses, and two variables. I run the pipeline every time something is changed inside the NuGet folder, except if it’s inside a Test folder. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 name : NuGet-CI-CD trigger: branches: include: - master paths: include: - NuGet/* exclude: - NuGet/**/*.Test pool: vmImage: &#39;ubuntu-latest&#39; variables: BuildConfiguration: Release ArtifactNuGetName: &#39;packages-nuget&#39; The next section defines a stage called build and creates a version number. If you want to learn more about the build versioning see Automatically Version Docker Containers in Azure DevOps CI. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 stages: - stage: build displayName: &#39;Build NuGet Package&#39; jobs: - job: CI_Build displayName: &#39;NuGet - Build, Pack and Test&#39; steps: - task: BuildVersioning@0 displayName: &#39;Build Versioning&#39; inputs: versionSource: &#39;gitversion&#39; doInstallGitVersion: true GitVersionInstallerSource: &#39;choco&#39; GitVersionInstallerVersion: &#39;5.0.1&#39; doUseLatestGitVersionInstallerVersion: false paramAssemblyVersion: &#39;7&#39; paramAssemblyFileVersion: &#39;7&#39; paramAssemblyInformationalVersion: &#39;6&#39; paramOverwriteFourthDigitWithBuildCounter: false paramVersionCode: &#39;2&#39; doAssemblyInfoAppendSuffix: false doConvertAssemblyInfoToLowerCase: true buildNumberVersionFormat: &#39;3&#39; buildNumberAction: &#39;replace&#39; doReplaceAssemblyInfo: false doReplaceNuspec: false doReplaceNpm: false doReplaceDotNetCore: true filePatternDotNetCore: | **\*.csproj **\*.props paramDotNetCoreVersionType: &#39;3&#39; doReplaceAndroid: false doReplaceiOS: false doReplaceCustom: false doShowWarningsForUnmatchedRegex: false excludeFilePattern: | !**/bin/** !**/obj/** !**/node_modules/** !**/packages/** After the version number is calculated, I execute dotnet restore and then dotnet build on all csproj files inside the NuGet folder. 1 2 3 4 5 6 7 8 9 10 11 12 13 - task: DotNetCoreCLI@2 displayName: &#39;Restore packages&#39; inputs: command: &#39;restore&#39; projects: &#39;NuGet/**/*.csproj&#39; feedsToUse: &#39;select&#39; - task: DotNetCoreCLI@2 displayName: &#39;Build solution&#39; inputs: command: &#39;build&#39; projects: &#39;NuGet/**/*.csproj&#39; arguments: &#39;-c $(BuildConfiguration) --no-restore&#39; The next step is to run the unit tests and publish the code coverage results. If a test fails, I will stop the pipeline and don’t create the NuGet package. 1 2 3 4 5 6 7 8 9 10 11 12 13 - task: DotNetCoreCLI@2 displayName: Run tests inputs: command: &#39;test&#39; projects: &#39;NuGet/**/*.Test.csproj&#39; arguments: &#39;-c $(BuildConfiguration) --no-build /p:CollectCoverage=true /p:CoverletOutputFormat=cobertura /p:CoverletOutput=$(Build.SourcesDirectory)/TestResults/Coverage/&#39; publishTestResults: true - task: PublishCodeCoverageResults@1 displayName: &#39;Publish code coverage report&#39; inputs: codeCoverageTool: &#39;Cobertura&#39; summaryFileLocation: &#39;$(Build.SourcesDirectory)/**/coverage.cobertura.xml&#39; The last two tasks create the NuGet package using dotnet pack and then publish the generate artifacts. Dotnet pack is executed on all project files inside the NuGet folder which don’t end with Test.csproj. This means that the test project doesn’t get packed into a NuGet package. The publish of the artifacts will be used in the next stage to publish the artifact to a private NuGet feed and in another stage to publish it to nuget.org. You can read about publishing in my next post. 1 2 3 4 5 6 7 8 9 10 11 12 13 - task: DotNetCoreCLI@2 displayName: &#39;Create nuget packages&#39; inputs: command: &#39;pack&#39; packagesToPack: &#39;NuGet/**/*.csproj;!**/*.Test.csproj&#39; packDirectory: &#39;$(Build.ArtifactStagingDirectory)/packages/nuget&#39; nobuild: true versioningScheme: &#39;byBuildNumber&#39; - publish: &#39;$(Build.ArtifactStagingDirectory)/packages/nuget&#39; displayName: &#39;Publish Artifact: $(ArtifactNuGetName)&#39; artifact: &#39;packages-nuget&#39; condition: and(succeeded(), ne(variables[&#39;Build.Reason&#39;], &#39;PullRequest&#39;)) You can find the finished pipeline on Github. Test the NuGet from the Pipeline Run the pipeline and after it is finished successfully, you can find the NuGet package as an attachment of the build. In your build click on 2 published. Find the NuGet package in the build Open the packages-nuget folder and there you can find the created NuGet package. The created NuGet package Download it and install it in your microservice. In my next post, I will show you how to automatically upload it to a NuGet feed in the Azure DevOps pipeline and how to install it from there. Conclusion Sharing code between microservices can be tricky but with NuGet packages, it is very simple and organized. In this post, I showed you how to automatically create a NuGet package using Azure DevOps pipelines. In my next post, I will show how to upload the NuGet package to a NuGet feed with the same Azure DevOps pipeline and how to use it in your microservices. You can find the code of the whole demo on Github. This post is part of “Microservice Series - From Zero to Hero”." /><link rel="canonical" href="https://www.programmingwithwolfgang.com/create-nuget-azure-devops/" /><meta property="og:url" content="https://www.programmingwithwolfgang.com/create-nuget-azure-devops/" /><meta property="og:site_name" content="Programming With Wolfgang" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-12-28T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Create NuGet Packages in Azure DevOps Pipelines" /><meta name="twitter:site" content="@wolfgang_ofner" /><meta name="twitter:creator" content="@Wolfgang Ofner" /><meta name="google-site-verification" content="xxsPm-h6A0B6a0QMgqXO80PU4DbMt4Dq06p-SGzB3TU" /> <script type="application/ld+json"> {"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.programmingwithwolfgang.com/create-nuget-azure-devops/"},"author":{"@type":"Person","name":"Wolfgang Ofner"},"url":"https://www.programmingwithwolfgang.com/create-nuget-azure-devops/","description":"I think the most important rule of a microservice is that it has to be deployed independently. When your project or company grows, it is very likely that you want to share code between projects or microservices. This leads to the question of how to share the code? Should you copy it into your microservice, reference dlls, or should every team develop its own code independently? In this post, I will show how to share code using NuGet packages and how to automatically create them in an Azure DevOps pipeline. How to share Code between Microservices There are several methods of sharing code between microservices but I think most of them are bad. Let’s have a look at the available options. Don’t share Code Not sharing code between microservices helps to keep them independent but this means that each microservice must develop all features by itself. This can lead to a lot of unnecessary development time and therefore costs a lot of money. Therefore, not sharing code is not an option. Referencing Dlls I prefer having all microservices in a big repository. This allows you to reference code from a different project. You could create a Shared folder and create in there projects which are shared between several microservices. The problem with this approach is that when one team changes the code, it changes the code for all microservices that reference the code. This will certainly lead to unintended and unexpected behavior. Since we want bug-free code, this option is not good to share code. Create Code and then copy it to Microservices Another option would be to create a new project with the code and use this code as the base for further developments. If a microservice wants to use this code, then copy it into their own project and then can edit it without interfering with other microservices. This solution sounds better than the previous one but this leads to a lot of overhead. All these versions will go in different directions, therefore it will take a lot of time to do simple changes, for example, updating the .NET version of the project. This has to be done in each implementation instead of in one central one. Therefore this solution is also not good. Share Code with NuGet Packages If you want to get external code and have control over it, NuGet packages are perfect. You can install the version you need and also can update whenever you have to. If the NuGet package gets updated but you don’t want to update yours, it’s no problem at all. The source code of the NuGet package exists only once, therefore it can be updated or modified quickly. Once a new version is released, every microservice can update it whenever they want. Create the Source for the NuGet Package You can find the code of the whole demo on Github. For this Demo, I will create a simple NuGet package that offers one method which takes an integer and then calculates a prime number, depending on the input. Prime numbers are, for example, 2, 3, 5, 7, 11, and so on. The input parameter indicates the number you want, for example, if you input 2, the second prime number, 3, is returned. If you input 4, the fourth prime number, 7 is returned. I know this is not going to be the most useful NuGet package but calculating prime numbers is quite CPU intensive and I will use this method in a later example to demonstrate autoscaling if the CPU limit is reached. I created a new folder in the root of my repository and called it NuGet. Inside this folder, I created a new folder called Prime Number which contains a new .NET 5 class library project. The class library consists only of one class with one method to calculate the prime number. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 public static class PrimeNumber { /// &lt;summary&gt; /// Provide a parameter nThPrimeNumber and find the nThPrimeNumber-th prime number. /// &lt;/summary&gt; /// &lt;param name=&quot;nThPrimeNumber&quot;&gt;The nThPrimeNumber-th prime number to find.&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static long FindNthPrimeNumber(int nThPrimeNumber) { var count = 0; long a = 2; while (count &lt; nThPrimeNumber) { long b = 2; var prime = 1; while (b * b &lt;= a) { if (a % b == 0) { prime = 0; break; } b++; } if (prime &gt; 0) { count++; } a++; } return --a; } } To make sure that the code does what I expect it to do, I created a test project to test it. 1 2 3 4 5 6 7 8 9 10 11 12 13 public class PrimeNumberTests { [Theory] [InlineData(3, 5)] [InlineData(5, 11)] [InlineData(50, 229)] public void FindNthPrimeNumber(int nThPrimeNumber, int expectedResult) { var result = PrimeNumber.FindNthPrimeNumber(nThPrimeNumber) result.Should().Be(expectedResult); } } That’s already all the code you need for the NuGet package. You could create the NuGet package manually by executing nuget pack in the root folder of the project but in the next section, I will show you how to create it automatically in an Azure DevOps pipeline. Create NuGet Package in Azure DevOps Pipeline I created a new pipeline in Azure DevOps to create the NuGet package. For more information about the basics of build pipelines read my post Build .NET Core in a CI Pipeline in Azure DevOps. The pipeline is going to be very simple but let’s have a look step-by-step. The first part is configuring when the pipeline should run, what agent it uses, and two variables. I run the pipeline every time something is changed inside the NuGet folder, except if it’s inside a Test folder. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 name : NuGet-CI-CD trigger: branches: include: - master paths: include: - NuGet/* exclude: - NuGet/**/*.Test pool: vmImage: &#39;ubuntu-latest&#39; variables: BuildConfiguration: Release ArtifactNuGetName: &#39;packages-nuget&#39; The next section defines a stage called build and creates a version number. If you want to learn more about the build versioning see Automatically Version Docker Containers in Azure DevOps CI. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 stages: - stage: build displayName: &#39;Build NuGet Package&#39; jobs: - job: CI_Build displayName: &#39;NuGet - Build, Pack and Test&#39; steps: - task: BuildVersioning@0 displayName: &#39;Build Versioning&#39; inputs: versionSource: &#39;gitversion&#39; doInstallGitVersion: true GitVersionInstallerSource: &#39;choco&#39; GitVersionInstallerVersion: &#39;5.0.1&#39; doUseLatestGitVersionInstallerVersion: false paramAssemblyVersion: &#39;7&#39; paramAssemblyFileVersion: &#39;7&#39; paramAssemblyInformationalVersion: &#39;6&#39; paramOverwriteFourthDigitWithBuildCounter: false paramVersionCode: &#39;2&#39; doAssemblyInfoAppendSuffix: false doConvertAssemblyInfoToLowerCase: true buildNumberVersionFormat: &#39;3&#39; buildNumberAction: &#39;replace&#39; doReplaceAssemblyInfo: false doReplaceNuspec: false doReplaceNpm: false doReplaceDotNetCore: true filePatternDotNetCore: | **\\*.csproj **\\*.props paramDotNetCoreVersionType: &#39;3&#39; doReplaceAndroid: false doReplaceiOS: false doReplaceCustom: false doShowWarningsForUnmatchedRegex: false excludeFilePattern: | !**/bin/** !**/obj/** !**/node_modules/** !**/packages/** After the version number is calculated, I execute dotnet restore and then dotnet build on all csproj files inside the NuGet folder. 1 2 3 4 5 6 7 8 9 10 11 12 13 - task: DotNetCoreCLI@2 displayName: &#39;Restore packages&#39; inputs: command: &#39;restore&#39; projects: &#39;NuGet/**/*.csproj&#39; feedsToUse: &#39;select&#39; - task: DotNetCoreCLI@2 displayName: &#39;Build solution&#39; inputs: command: &#39;build&#39; projects: &#39;NuGet/**/*.csproj&#39; arguments: &#39;-c $(BuildConfiguration) --no-restore&#39; The next step is to run the unit tests and publish the code coverage results. If a test fails, I will stop the pipeline and don’t create the NuGet package. 1 2 3 4 5 6 7 8 9 10 11 12 13 - task: DotNetCoreCLI@2 displayName: Run tests inputs: command: &#39;test&#39; projects: &#39;NuGet/**/*.Test.csproj&#39; arguments: &#39;-c $(BuildConfiguration) --no-build /p:CollectCoverage=true /p:CoverletOutputFormat=cobertura /p:CoverletOutput=$(Build.SourcesDirectory)/TestResults/Coverage/&#39; publishTestResults: true - task: PublishCodeCoverageResults@1 displayName: &#39;Publish code coverage report&#39; inputs: codeCoverageTool: &#39;Cobertura&#39; summaryFileLocation: &#39;$(Build.SourcesDirectory)/**/coverage.cobertura.xml&#39; The last two tasks create the NuGet package using dotnet pack and then publish the generate artifacts. Dotnet pack is executed on all project files inside the NuGet folder which don’t end with Test.csproj. This means that the test project doesn’t get packed into a NuGet package. The publish of the artifacts will be used in the next stage to publish the artifact to a private NuGet feed and in another stage to publish it to nuget.org. You can read about publishing in my next post. 1 2 3 4 5 6 7 8 9 10 11 12 13 - task: DotNetCoreCLI@2 displayName: &#39;Create nuget packages&#39; inputs: command: &#39;pack&#39; packagesToPack: &#39;NuGet/**/*.csproj;!**/*.Test.csproj&#39; packDirectory: &#39;$(Build.ArtifactStagingDirectory)/packages/nuget&#39; nobuild: true versioningScheme: &#39;byBuildNumber&#39; - publish: &#39;$(Build.ArtifactStagingDirectory)/packages/nuget&#39; displayName: &#39;Publish Artifact: $(ArtifactNuGetName)&#39; artifact: &#39;packages-nuget&#39; condition: and(succeeded(), ne(variables[&#39;Build.Reason&#39;], &#39;PullRequest&#39;)) You can find the finished pipeline on Github. Test the NuGet from the Pipeline Run the pipeline and after it is finished successfully, you can find the NuGet package as an attachment of the build. In your build click on 2 published. Find the NuGet package in the build Open the packages-nuget folder and there you can find the created NuGet package. The created NuGet package Download it and install it in your microservice. In my next post, I will show you how to automatically upload it to a NuGet feed in the Azure DevOps pipeline and how to install it from there. Conclusion Sharing code between microservices can be tricky but with NuGet packages, it is very simple and organized. In this post, I showed you how to automatically create a NuGet package using Azure DevOps pipelines. In my next post, I will show how to upload the NuGet package to a NuGet feed with the same Azure DevOps pipeline and how to use it in your microservices. You can find the code of the whole demo on Github. This post is part of “Microservice Series - From Zero to Hero”.","@type":"BlogPosting","headline":"Create NuGet Packages in Azure DevOps Pipelines","dateModified":"2021-01-03T18:24:37+01:00","datePublished":"2020-12-28T00:00:00+01:00","@context":"https://schema.org"}</script><title>Create NuGet Packages in Azure DevOps Pipelines | Programming With Wolfgang</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="preload" href="/assets/css/post.css" as="style"><link rel="stylesheet" href="/assets/css/post.css"><link rel="preload" as="style" href="/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/css/lib/bootstrap-toc.min.css" /> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="/assets/js/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-112077092-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-112077092-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/author/wolfgang-small.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Programming With Wolfgang</a></div><div class="site-subtitle font-italic">Let's talk programming</div></div><div class="w-100 d-flex justify-content-center"> <i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span></div><ul class="w-100" style="margin-top: 1em;"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tabs/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tabs/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/tabs/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/tabs/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/wolfgangofner" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/wolfgang_ofner" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href="https://www.linkedin.com/in/wolfgangofner" aria-label="linkedin" class="order-5" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['wolfgang','programmingwithwolfgang.com'].join('@')" aria-label="email" class="order-6" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-7" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="d-sm-none row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Create NuGet Packages in Azure DevOps Pipelines</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Create NuGet Packages in Azure DevOps Pipelines</div><div style="visibility:hidden;"> <i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel">Cancel</span></div></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Create NuGet Packages in Azure DevOps Pipelines</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Mon, Dec 28, 2020, 12:00 AM +0100" > Dec 28, 2020 <i class="unloaded">2020-12-28T00:00:00+01:00</i> </span> by <span class="author"> Wolfgang Ofner </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sun, Jan 3, 2021, 6:24 PM +0100" > Jan 3 <i class="unloaded">2021-01-03T18:24:37+01:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1633 words">25 min</span></div></div><div class="post-content"><p>I think the most important rule of a microservice is that it has to be deployed independently. When your project or company grows, it is very likely that you want to share code between projects or microservices. This leads to the question of how to share the code? Should you copy it into your microservice, reference dlls, or should every team develop its own code independently?</p><p>In this post, I will show how to share code using NuGet packages and how to automatically create them in an Azure DevOps pipeline.</p><h2 id="how-to-share-code-between-microservices">How to share Code between Microservices</h2><p>There are several methods of sharing code between microservices but I think most of them are bad. Let’s have a look at the available options.</p><h3 id="dont-share-code">Don’t share Code</h3><p>Not sharing code between microservices helps to keep them independent but this means that each microservice must develop all features by itself. This can lead to a lot of unnecessary development time and therefore costs a lot of money. Therefore, not sharing code is not an option.</p><h3 id="referencing-dlls">Referencing Dlls</h3><p>I prefer having all microservices in a big repository. This allows you to reference code from a different project. You could create a Shared folder and create in there projects which are shared between several microservices. The problem with this approach is that when one team changes the code, it changes the code for all microservices that reference the code. This will certainly lead to unintended and unexpected behavior. Since we want bug-free code, this option is not good to share code.</p><h3 id="create-code-and-then-copy-it-to-microservices">Create Code and then copy it to Microservices</h3><p>Another option would be to create a new project with the code and use this code as the base for further developments. If a microservice wants to use this code, then copy it into their own project and then can edit it without interfering with other microservices. This solution sounds better than the previous one but this leads to a lot of overhead. All these versions will go in different directions, therefore it will take a lot of time to do simple changes, for example, updating the .NET version of the project. This has to be done in each implementation instead of in one central one. Therefore this solution is also not good.</p><h3 id="share-code-with-nuget-packages">Share Code with NuGet Packages</h3><p>If you want to get external code and have control over it, NuGet packages are perfect. You can install the version you need and also can update whenever you have to. If the NuGet package gets updated but you don’t want to update yours, it’s no problem at all. The source code of the NuGet package exists only once, therefore it can be updated or modified quickly. Once a new version is released, every microservice can update it whenever they want.</p><h2 id="create-the-source-for-the-nuget-package">Create the Source for the NuGet Package</h2><p>You can find the code of the whole demo on <a href="https://github.com/WolfgangOfner/MicroserviceDemo" target="_blank" rel="noopener noreferrer">Github</a>.</p><p>For this Demo, I will create a simple NuGet package that offers one method which takes an integer and then calculates a prime number, depending on the input. Prime numbers are, for example, 2, 3, 5, 7, 11, and so on. The input parameter indicates the number you want, for example, if you input 2, the second prime number, 3, is returned. If you input 4, the fourth prime number, 7 is returned. I know this is not going to be the most useful NuGet package but calculating prime numbers is quite CPU intensive and I will use this method in a later example to demonstrate autoscaling if the CPU limit is reached.</p><p>I created a new folder in the root of my repository and called it NuGet. Inside this folder, I created a new folder called Prime Number which contains a new .NET 5 class library project. The class library consists only of one class with one method to calculate the prime number.</p><div class="language-csharp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">PrimeNumber</span>
<span class="p">{</span>
    <span class="c1">/// &lt;summary&gt;</span>
    <span class="c1">/// Provide a parameter nThPrimeNumber and find the nThPrimeNumber-th prime number.</span>
    <span class="c1">/// &lt;/summary&gt;</span>
    <span class="c1">/// &lt;param name="nThPrimeNumber"&gt;The nThPrimeNumber-th prime number to find.&lt;/param&gt;</span>
    <span class="c1">/// &lt;returns&gt;&lt;/returns&gt;</span>
    <span class="k">public</span> <span class="k">static</span> <span class="kt">long</span> <span class="nf">FindNthPrimeNumber</span><span class="p">(</span><span class="kt">int</span> <span class="n">nThPrimeNumber</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">count</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="kt">long</span> <span class="n">a</span> <span class="p">=</span> <span class="m">2</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="p">&lt;</span> <span class="n">nThPrimeNumber</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">long</span> <span class="n">b</span> <span class="p">=</span> <span class="m">2</span><span class="p">;</span>
            <span class="kt">var</span> <span class="n">prime</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span> 

            <span class="k">while</span> <span class="p">(</span><span class="n">b</span> <span class="p">*</span> <span class="n">b</span> <span class="p">&lt;=</span> <span class="n">a</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="p">%</span> <span class="n">b</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">prime</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="n">b</span><span class="p">++;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">prime</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">count</span><span class="p">++;</span>
            <span class="p">}</span>

            <span class="n">a</span><span class="p">++;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="p">--</span><span class="n">a</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>To make sure that the code does what I expect it to do, I created a test project to test it.</p><div class="language-csharp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">class</span> <span class="nc">PrimeNumberTests</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">Theory</span><span class="p">]</span>
    <span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="m">5</span><span class="p">)]</span>
    <span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="m">5</span><span class="p">,</span> <span class="m">11</span><span class="p">)]</span>
    <span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="m">50</span><span class="p">,</span> <span class="m">229</span><span class="p">)]</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">FindNthPrimeNumber</span><span class="p">(</span><span class="kt">int</span> <span class="n">nThPrimeNumber</span><span class="p">,</span> <span class="kt">int</span> <span class="n">expectedResult</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="n">PrimeNumber</span><span class="p">.</span><span class="nf">FindNthPrimeNumber</span><span class="p">(</span><span class="n">nThPrimeNumber</span><span class="p">)</span>
        
        <span class="n">result</span><span class="p">.</span><span class="nf">Should</span><span class="p">().</span><span class="nf">Be</span><span class="p">(</span><span class="n">expectedResult</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>That’s already all the code you need for the NuGet package. You could create the NuGet package manually by executing nuget pack in the root folder of the project but in the next section, I will show you how to create it automatically in an Azure DevOps pipeline.</p><h2 id="create-nuget-package-in-azure-devops-pipeline">Create NuGet Package in Azure DevOps Pipeline</h2><p>I created a new pipeline in Azure DevOps to create the NuGet package. For more information about the basics of build pipelines read my post <a href="/build-net-core-in-ci-pipeline-in-azure-devops">Build .NET Core in a CI Pipeline in Azure DevOps</a>.</p><p>The pipeline is going to be very simple but let’s have a look step-by-step.</p><p>The first part is configuring when the pipeline should run, what agent it uses, and two variables. I run the pipeline every time something is changed inside the NuGet folder, except if it’s inside a Test folder.</p><div class="language-yaml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="na">name </span><span class="pi">:</span> <span class="s">NuGet-CI-CD</span>
<span class="na">trigger</span><span class="pi">:</span>
  <span class="na">branches</span><span class="pi">:</span>
    <span class="na">include</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">master</span>
  <span class="na">paths</span><span class="pi">:</span>
    <span class="na">include</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">NuGet/*</span>
    <span class="na">exclude</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">NuGet/**/*.Test</span>

<span class="na">pool</span><span class="pi">:</span>
  <span class="na">vmImage</span><span class="pi">:</span> <span class="s1">'</span><span class="s">ubuntu-latest'</span>

<span class="na">variables</span><span class="pi">:</span>
  <span class="na">BuildConfiguration</span><span class="pi">:</span> <span class="s">Release</span>
  <span class="na">ArtifactNuGetName</span><span class="pi">:</span> <span class="s1">'</span><span class="s">packages-nuget'</span>
</pre></table></code></div></div><p>The next section defines a stage called build and creates a version number. If you want to learn more about the build versioning see <a href="/automatically-version-docker-container">Automatically Version Docker Containers in Azure DevOps CI</a>.</p><div class="language-yaml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="na">stages</span><span class="pi">:</span>
<span class="pi">-</span> <span class="na">stage</span><span class="pi">:</span> <span class="s">build</span>
  <span class="na">displayName</span><span class="pi">:</span> <span class="s1">'</span><span class="s">Build</span><span class="nv"> </span><span class="s">NuGet</span><span class="nv"> </span><span class="s">Package'</span>
  <span class="na">jobs</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">job</span><span class="pi">:</span> <span class="s">CI_Build</span>
    <span class="na">displayName</span><span class="pi">:</span> <span class="s1">'</span><span class="s">NuGet</span><span class="nv"> </span><span class="s">-</span><span class="nv"> </span><span class="s">Build,</span><span class="nv"> </span><span class="s">Pack</span><span class="nv"> </span><span class="s">and</span><span class="nv"> </span><span class="s">Test'</span>    
    <span class="na">steps</span><span class="pi">:</span>

    <span class="pi">-</span> <span class="na">task</span><span class="pi">:</span> <span class="s">BuildVersioning@0</span>
      <span class="na">displayName</span><span class="pi">:</span> <span class="s1">'</span><span class="s">Build</span><span class="nv"> </span><span class="s">Versioning'</span>
      <span class="na">inputs</span><span class="pi">:</span>
        <span class="na">versionSource</span><span class="pi">:</span> <span class="s1">'</span><span class="s">gitversion'</span>
        <span class="na">doInstallGitVersion</span><span class="pi">:</span> <span class="no">true</span>
        <span class="na">GitVersionInstallerSource</span><span class="pi">:</span> <span class="s1">'</span><span class="s">choco'</span>
        <span class="na">GitVersionInstallerVersion</span><span class="pi">:</span> <span class="s1">'</span><span class="s">5.0.1'</span>
        <span class="na">doUseLatestGitVersionInstallerVersion</span><span class="pi">:</span> <span class="no">false</span>
        <span class="na">paramAssemblyVersion</span><span class="pi">:</span> <span class="s1">'</span><span class="s">7'</span>
        <span class="na">paramAssemblyFileVersion</span><span class="pi">:</span> <span class="s1">'</span><span class="s">7'</span>
        <span class="na">paramAssemblyInformationalVersion</span><span class="pi">:</span> <span class="s1">'</span><span class="s">6'</span>
        <span class="na">paramOverwriteFourthDigitWithBuildCounter</span><span class="pi">:</span> <span class="no">false</span>
        <span class="na">paramVersionCode</span><span class="pi">:</span> <span class="s1">'</span><span class="s">2'</span>
        <span class="na">doAssemblyInfoAppendSuffix</span><span class="pi">:</span> <span class="no">false</span>
        <span class="na">doConvertAssemblyInfoToLowerCase</span><span class="pi">:</span> <span class="no">true</span>
        <span class="na">buildNumberVersionFormat</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3'</span>
        <span class="na">buildNumberAction</span><span class="pi">:</span> <span class="s1">'</span><span class="s">replace'</span>
        <span class="na">doReplaceAssemblyInfo</span><span class="pi">:</span> <span class="no">false</span>
        <span class="na">doReplaceNuspec</span><span class="pi">:</span> <span class="no">false</span>
        <span class="na">doReplaceNpm</span><span class="pi">:</span> <span class="no">false</span>
        <span class="na">doReplaceDotNetCore</span><span class="pi">:</span> <span class="no">true</span>
        <span class="na">filePatternDotNetCore</span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">**\*.csproj</span>
          <span class="s">**\*.props</span>
        <span class="na">paramDotNetCoreVersionType</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3'</span>
        <span class="na">doReplaceAndroid</span><span class="pi">:</span> <span class="no">false</span>
        <span class="na">doReplaceiOS</span><span class="pi">:</span> <span class="no">false</span>
        <span class="na">doReplaceCustom</span><span class="pi">:</span> <span class="no">false</span>
        <span class="na">doShowWarningsForUnmatchedRegex</span><span class="pi">:</span> <span class="no">false</span>
        <span class="na">excludeFilePattern</span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">!**/bin/**</span>
          <span class="s">!**/obj/**</span>
          <span class="s">!**/node_modules/**</span>
          <span class="s">!**/packages/**</span>
</pre></table></code></div></div><p>After the version number is calculated, I execute dotnet restore and then dotnet build on all csproj files inside the NuGet folder.</p><div class="language-yaml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>    <span class="pi">-</span> <span class="na">task</span><span class="pi">:</span> <span class="s">DotNetCoreCLI@2</span>
      <span class="na">displayName</span><span class="pi">:</span> <span class="s1">'</span><span class="s">Restore</span><span class="nv"> </span><span class="s">packages'</span>
      <span class="na">inputs</span><span class="pi">:</span>
        <span class="na">command</span><span class="pi">:</span> <span class="s1">'</span><span class="s">restore'</span>
        <span class="na">projects</span><span class="pi">:</span> <span class="s1">'</span><span class="s">NuGet/**/*.csproj'</span>
        <span class="na">feedsToUse</span><span class="pi">:</span> <span class="s1">'</span><span class="s">select'</span>

    <span class="pi">-</span> <span class="na">task</span><span class="pi">:</span> <span class="s">DotNetCoreCLI@2</span>
      <span class="na">displayName</span><span class="pi">:</span> <span class="s1">'</span><span class="s">Build</span><span class="nv"> </span><span class="s">solution'</span>
      <span class="na">inputs</span><span class="pi">:</span>
        <span class="na">command</span><span class="pi">:</span> <span class="s1">'</span><span class="s">build'</span>
        <span class="na">projects</span><span class="pi">:</span> <span class="s1">'</span><span class="s">NuGet/**/*.csproj'</span>
        <span class="na">arguments</span><span class="pi">:</span> <span class="s1">'</span><span class="s">-c</span><span class="nv"> </span><span class="s">$(BuildConfiguration)</span><span class="nv"> </span><span class="s">--no-restore'</span>
</pre></table></code></div></div><p>The next step is to run the unit tests and publish the code coverage results. If a test fails, I will stop the pipeline and don’t create the NuGet package.</p><div class="language-yaml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>    <span class="pi">-</span> <span class="na">task</span><span class="pi">:</span> <span class="s">DotNetCoreCLI@2</span>
      <span class="na">displayName</span><span class="pi">:</span> <span class="s">Run tests</span>
      <span class="na">inputs</span><span class="pi">:</span>
        <span class="na">command</span><span class="pi">:</span> <span class="s1">'</span><span class="s">test'</span>        
        <span class="na">projects</span><span class="pi">:</span> <span class="s1">'</span><span class="s">NuGet/**/*.Test.csproj'</span>
        <span class="na">arguments</span><span class="pi">:</span> <span class="s1">'</span><span class="s">-c</span><span class="nv"> </span><span class="s">$(BuildConfiguration)</span><span class="nv"> </span><span class="s">--no-build</span><span class="nv"> </span><span class="s">/p:CollectCoverage=true</span><span class="nv"> </span><span class="s">/p:CoverletOutputFormat=cobertura</span><span class="nv"> </span><span class="s">/p:CoverletOutput=$(Build.SourcesDirectory)/TestResults/Coverage/'</span>
        <span class="na">publishTestResults</span><span class="pi">:</span> <span class="no">true</span>

    <span class="pi">-</span> <span class="na">task</span><span class="pi">:</span> <span class="s">PublishCodeCoverageResults@1</span>
      <span class="na">displayName</span><span class="pi">:</span> <span class="s1">'</span><span class="s">Publish</span><span class="nv"> </span><span class="s">code</span><span class="nv"> </span><span class="s">coverage</span><span class="nv"> </span><span class="s">report'</span>
      <span class="na">inputs</span><span class="pi">:</span>
        <span class="na">codeCoverageTool</span><span class="pi">:</span> <span class="s1">'</span><span class="s">Cobertura'</span>
        <span class="na">summaryFileLocation</span><span class="pi">:</span> <span class="s1">'</span><span class="s">$(Build.SourcesDirectory)/**/coverage.cobertura.xml'</span>
</pre></table></code></div></div><p>The last two tasks create the NuGet package using dotnet pack and then publish the generate artifacts. Dotnet pack is executed on all project files inside the NuGet folder which don’t end with Test.csproj. This means that the test project doesn’t get packed into a NuGet package. The publish of the artifacts will be used in the next stage to publish the artifact to a private NuGet feed and in another stage to publish it to nuget.org. You can read about publishing in my next post.</p><div class="language-yaml highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>    <span class="pi">-</span> <span class="na">task</span><span class="pi">:</span> <span class="s">DotNetCoreCLI@2</span>
      <span class="na">displayName</span><span class="pi">:</span> <span class="s1">'</span><span class="s">Create</span><span class="nv"> </span><span class="s">nuget</span><span class="nv"> </span><span class="s">packages'</span>
      <span class="na">inputs</span><span class="pi">:</span>
        <span class="na">command</span><span class="pi">:</span> <span class="s1">'</span><span class="s">pack'</span>
        <span class="na">packagesToPack</span><span class="pi">:</span> <span class="s1">'</span><span class="s">NuGet/**/*.csproj;!**/*.Test.csproj'</span>
        <span class="na">packDirectory</span><span class="pi">:</span> <span class="s1">'</span><span class="s">$(Build.ArtifactStagingDirectory)/packages/nuget'</span>
        <span class="na">nobuild</span><span class="pi">:</span> <span class="no">true</span>
        <span class="na">versioningScheme</span><span class="pi">:</span> <span class="s1">'</span><span class="s">byBuildNumber'</span>

    <span class="pi">-</span> <span class="na">publish</span><span class="pi">:</span> <span class="s1">'</span><span class="s">$(Build.ArtifactStagingDirectory)/packages/nuget'</span>
      <span class="na">displayName</span><span class="pi">:</span> <span class="s1">'</span><span class="s">Publish</span><span class="nv"> </span><span class="s">Artifact:</span><span class="nv"> </span><span class="s">$(ArtifactNuGetName)'</span>
      <span class="na">artifact</span><span class="pi">:</span> <span class="s1">'</span><span class="s">packages-nuget'</span>
      <span class="na">condition</span><span class="pi">:</span> <span class="s">and(succeeded(), ne(variables['Build.Reason'], 'PullRequest'))</span>
</pre></table></code></div></div><p>You can find the finished pipeline on <a href="https://github.com/WolfgangOfner/MicroserviceDemo/blob/master/Nuget/pipelines/Nuget-CI-CD.yml" target="_blank" rel="noopener noreferrer">Github</a>.</p><h2 id="test-the-nuget-from-the-pipeline">Test the NuGet from the Pipeline</h2><p>Run the pipeline and after it is finished successfully, you can find the NuGet package as an attachment of the build. In your build click on 2 published.</p><div class="col-12 col-sm-10 aligncenter"> <a href="/assets/img/posts/2020/12/Find-the-Nuget-package-in-the-build.jpg"><img loading="lazy" src="/assets/img/posts/2020/12/Find-the-Nuget-package-in-the-build.jpg" alt="Find the NuGet package in the build" /></a><p> Find the NuGet package in the build</p></div><p>Open the packages-nuget folder and there you can find the created NuGet package.</p><div class="col-12 col-sm-10 aligncenter"> <a href="/assets/img/posts/2020/12/The-created-Nuget-package.jpg"><img loading="lazy" src="/assets/img/posts/2020/12/The-created-Nuget-package.jpg" alt="The created NuGet package" /></a><p> The created NuGet package</p></div><p>Download it and install it in your microservice. <a href="/publish-internal-nuget-feed">In my next post</a>, I will show you how to automatically upload it to a NuGet feed in the Azure DevOps pipeline and how to install it from there.</p><h2 id="conclusion">Conclusion</h2><p>Sharing code between microservices can be tricky but with NuGet packages, it is very simple and organized. In this post, I showed you how to automatically create a NuGet package using Azure DevOps pipelines. <a href="/publish-internal-nuget-feed">In my next post</a>, I will show how to upload the NuGet package to a NuGet feed with the same Azure DevOps pipeline and how to use it in your microservices.</p><p>You can find the code of the whole demo on <a href="https://github.com/WolfgangOfner/MicroserviceDemo" target="_blank" rel="noopener noreferrer">Github</a>.</p><p>This post is part of <a href="/microservice-series-from-zero-to-hero">“Microservice Series - From Zero to Hero”</a>.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/devops/'>DevOps</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/azure-devops/" class="post-tag no-text-decoration" >Azure DevOps</a> <a href="/tags/nuget/" class="post-tag no-text-decoration" >NuGet</a> <a href="/tags/ci/" class="post-tag no-text-decoration" >CI</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Create NuGet Packages in Azure DevOps Pipelines - Programming With Wolfgang&url=https://www.programmingwithwolfgang.com/create-nuget-azure-devops/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Create NuGet Packages in Azure DevOps Pipelines - Programming With Wolfgang&u=https://www.programmingwithwolfgang.com/create-nuget-azure-devops/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Create NuGet Packages in Azure DevOps Pipelines - Programming With Wolfgang&url=https://www.programmingwithwolfgang.com/create-nuget-azure-devops/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://www.programmingwithwolfgang.com/create-nuget-azure-devops/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/helm-getting-started/">Helm - Getting Started</a><li><a href="/override-appsettings-in-kubernetes/">Override Appsettings in Kubernetes</a><li><a href="/mediator-pattern-in-asp-net-core-3-1/">Mediator Pattern in ASP .NET Core 3.1</a><li><a href="/microservice-series-from-zero-to-hero/">Microservice Series - From Zero to Hero</a><li><a href="/blazor-server-vs-blazor-webassembly/">Blazor Server vs. Blazor WebAssembly</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/c/">C#</a> <a class="post-tag" href="/tags/azure/">Azure</a> <a class="post-tag" href="/tags/learning/">Learning</a> <a class="post-tag" href="/tags/70-532/">70-532</a> <a class="post-tag" href="/tags/certification/">Certification</a> <a class="post-tag" href="/tags/exam/">Exam</a> <a class="post-tag" href="/tags/docker/">Docker</a> <a class="post-tag" href="/tags/azure-devops/">Azure DevOps</a> <a class="post-tag" href="/tags/net-core/">NET Core</a> <a class="post-tag" href="/tags/microservice/">Microservice</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/publish-internal-nuget-feed/"><div class="card-body"> <span class="timeago small" > Jan 4 <i class="unloaded">2021-01-04T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Publish to an Internal NuGet Feed in Azure DevOps</h3><div class="text-muted small"><p> In my last posts, I showed how to create NuGet packages in Azure DevOps pipelines. To easily distribute them, you have to publish these NuGet packages to a NuGet feed. This can be done by using nug...</p></div></div></a></div><div class="card"> <a href="/restore-nuget-inside-docker/"><div class="card-body"> <span class="timeago small" > Jan 11 <i class="unloaded">2021-01-11T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Restore NuGet Packages from a Private Feed when building Docker Containers</h3><div class="text-muted small"><p> In my last posts, I created a private NuGet feed and automatically uploaded a NuGet package with my Azure DevOps pipeline. Using Visual Studio to restore the NuGet package from the private feed wor...</p></div></div></a></div><div class="card"> <a href="/azure-devops-publish-nuget/"><div class="card-body"> <span class="timeago small" > Jan 18 <i class="unloaded">2021-01-18T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Publish NuGet Packages to Nuget.org using Azure DevOps Pipelines</h3><div class="text-muted small"><p> In my last posts, I published my NuGet package to a private NuGet feed. This is a good solution if you want to use your NuGet packages only internally. If you want to share them, you need a public ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/automatically-version-docker-container/" class="btn btn-outline-primary"><p>Automatically Version Docker Containers in Azure DevOps CI</p></a> <a href="/publish-internal-nuget-feed/" class="btn btn-outline-primary"><p>Publish to an Internal NuGet Feed in Azure DevOps</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="font-italic text-center text-muted small"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> var options = { scriptUrl: '//programmingwithwolfgang.disqus.com/embed.js', disqusConfig: function() { this.page.url = 'https://www.programmingwithwolfgang.com/create-nuget-azure-devops/'; this.page.identifier = '/create-nuget-azure-devops/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://twitter.com/wolfgang_ofner">Wolfgang Ofner</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy/" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/c/">C#</a> <a class="post-tag" href="/tags/azure/">Azure</a> <a class="post-tag" href="/tags/learning/">Learning</a> <a class="post-tag" href="/tags/70-532/">70 532</a> <a class="post-tag" href="/tags/certification/">Certification</a> <a class="post-tag" href="/tags/exam/">Exam</a> <a class="post-tag" href="/tags/docker/">Docker</a> <a class="post-tag" href="/tags/azure-devops/">Azure DevOps</a> <a class="post-tag" href="/tags/net-core/">NET Core</a> <a class="post-tag" href="/tags/microservice/">Microservice</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.programmingwithwolfgang.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
